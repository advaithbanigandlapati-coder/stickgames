<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CROWBAR CLIMBERS</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
:root{
  --orange:#FF6B00;
  --red:#FF2200;
  --cyan:#00FFE5;
  --purple:#9B4DFF;
  --gold:#FFD000;
  --dark:#05030A;
}

body{
  background:#000;
  overflow:hidden;
  font-family:'Bebas Neue',sans-serif;
  cursor:none;
}

canvas{display:block;}

/* CUSTOM CURSOR */
#cursor{
  position:fixed;width:14px;height:14px;
  border:2px solid var(--orange);border-radius:50%;
  pointer-events:none;z-index:9999;
  transform:translate(-50%,-50%);
  background:rgba(255,107,0,0.15);
  box-shadow:0 0 12px var(--orange),0 0 4px var(--orange);
  transition:transform 0.1s;
}
#cursor::after{
  content:'';position:absolute;top:50%;left:50%;
  width:3px;height:3px;background:var(--orange);
  border-radius:50%;transform:translate(-50%,-50%);
}

/* CHROME VIGNETTE */
#vignette{
  position:fixed;inset:0;pointer-events:none;z-index:50;
  background:radial-gradient(ellipse at center,transparent 55%,rgba(0,0,0,0.85) 100%);
}

/* SCANLINES */
#scanlines{
  position:fixed;inset:0;pointer-events:none;z-index:51;
  background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);
  opacity:0.4;
}

/* CHROMATIC ABERRATION OVERLAY (JS animated) */
#chroma{
  position:fixed;inset:0;pointer-events:none;z-index:52;
  opacity:0;transition:opacity 0.1s;
  background:transparent;
}

/* SCREEN FLASH */
#flash{
  position:fixed;inset:0;pointer-events:none;z-index:53;
  background:rgba(255,107,0,0.4);opacity:0;
  transition:opacity 0.05s;
}

/* â”€â”€â”€ MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#menu{
  position:fixed;inset:0;z-index:200;
  display:flex;align-items:center;justify-content:center;
  background:var(--dark);
}
#menu.hide{display:none;}

.menu-bg{
  position:absolute;inset:0;
  background:
    radial-gradient(ellipse 80% 60% at 50% 100%,rgba(255,107,0,0.12) 0%,transparent 60%),
    radial-gradient(ellipse 40% 40% at 20% 30%,rgba(155,77,255,0.08) 0%,transparent 50%),
    radial-gradient(ellipse 40% 40% at 80% 20%,rgba(0,255,229,0.06) 0%,transparent 50%);
}

.menu-grid{
  position:absolute;inset:0;
  background-image:
    linear-gradient(rgba(255,107,0,0.06) 1px,transparent 1px),
    linear-gradient(90deg,rgba(255,107,0,0.06) 1px,transparent 1px);
  background-size:40px 40px;
  mask-image:radial-gradient(ellipse at center,black 30%,transparent 80%);
}

.menu-inner{
  position:relative;z-index:1;
  text-align:center;max-width:640px;padding:0 20px;
}

.menu-eyebrow{
  font-family:'Share Tech Mono',monospace;
  font-size:0.7rem;letter-spacing:6px;
  color:var(--orange);margin-bottom:14px;
  text-transform:uppercase;opacity:0.85;
}

.menu-title{
  font-size:clamp(4rem,10vw,7.5rem);
  letter-spacing:4px;
  line-height:0.9;
  color:#fff;
  text-transform:uppercase;
  text-shadow:
    0 0 60px rgba(255,107,0,0.5),
    0 0 20px rgba(255,107,0,0.3),
    4px 4px 0 rgba(255,107,0,0.3);
  margin-bottom:8px;
}

.menu-title span{color:var(--orange);}

.menu-sub{
  font-family:'Share Tech Mono',monospace;
  font-size:0.85rem;color:#666;
  letter-spacing:3px;margin-bottom:48px;
}

.menu-controls-grid{
  display:grid;grid-template-columns:1fr 1fr;gap:12px;
  margin-bottom:40px;
}

.ctrl-card{
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,107,0,0.2);
  border-radius:8px;padding:16px;text-align:left;
}

.ctrl-card-label{
  font-size:0.75rem;letter-spacing:3px;
  color:var(--orange);margin-bottom:8px;
}

.ctrl-card-keys{
  font-family:'Share Tech Mono',monospace;
  font-size:0.8rem;color:#aaa;line-height:1.8;
}

.ctrl-card-keys b{
  background:rgba(255,107,0,0.15);
  border:1px solid rgba(255,107,0,0.4);
  border-radius:4px;padding:1px 6px;
  color:#fff;font-size:0.75rem;
}

.play-btn{
  padding:18px 72px;
  background:linear-gradient(135deg,var(--orange) 0%,#FF2200 100%);
  border:none;border-radius:4px;
  color:#fff;font-family:'Bebas Neue',sans-serif;
  font-size:1.8rem;letter-spacing:6px;
  cursor:none;transition:all 0.25s;
  box-shadow:0 0 40px rgba(255,107,0,0.4),0 8px 25px rgba(0,0,0,0.4);
  text-transform:uppercase;
  position:relative;overflow:hidden;
}

.play-btn::before{
  content:'';position:absolute;inset:0;
  background:linear-gradient(135deg,rgba(255,255,255,0.15),transparent);
  transform:translateX(-100%);transition:transform 0.4s;
}

.play-btn:hover{
  transform:translateY(-3px);
  box-shadow:0 0 60px rgba(255,107,0,0.7),0 12px 35px rgba(0,0,0,0.5);
}

.play-btn:hover::before{transform:translateX(100%);}

.menu-tagline{
  margin-top:20px;
  font-family:'Share Tech Mono',monospace;
  font-size:0.7rem;color:#444;letter-spacing:2px;
}

/* â”€â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#hud{
  position:fixed;top:0;left:0;right:0;z-index:100;
  padding:12px 16px;
  display:none;align-items:flex-start;gap:10px;
  background:rgba(4,2,8,0.82);
  backdrop-filter:blur(14px);
  border-bottom:1px solid rgba(255,107,0,0.18);
  box-shadow:0 4px 30px rgba(0,0,0,0.6);
}
#hud.show{display:flex;}

.hud-stat{
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,107,0,0.15);
  border-radius:6px;padding:8px 14px;
  min-width:80px;
}

.hud-label{
  font-family:'Share Tech Mono',monospace;
  font-size:0.6rem;letter-spacing:3px;
  color:rgba(255,107,0,0.7);margin-bottom:2px;
  text-transform:uppercase;
}

.hud-value{
  font-size:1.8rem;color:#fff;
  text-shadow:0 0 12px rgba(255,255,255,0.3);
  line-height:1;
}

/* Stamina */
.stamina-wrap{
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,107,0,0.15);
  border-radius:6px;padding:8px 14px;
  flex:1;max-width:220px;
}

.stamina-track{
  height:6px;background:rgba(255,255,255,0.08);
  border-radius:3px;overflow:hidden;margin-top:6px;
}

.stamina-bar{
  height:100%;width:100%;
  background:linear-gradient(90deg,var(--orange),#FFD000);
  border-radius:3px;transition:width 0.1s linear;
  box-shadow:0 0 8px rgba(255,107,0,0.8);
}

.stamina-bar.low{animation:stamBlink 0.4s ease infinite;}
@keyframes stamBlink{0%,100%{opacity:1;}50%{opacity:0.3;}}

/* Stage indicator */
.stage-badge{
  margin-left:auto;
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,107,0,0.15);
  border-radius:6px;padding:8px 14px;
  text-align:right;
}

.stage-name{
  font-size:1rem;letter-spacing:3px;color:var(--orange);
}

.stage-progress{
  font-family:'Share Tech Mono',monospace;
  font-size:0.65rem;color:#666;
  letter-spacing:2px;margin-top:2px;
}

/* Checkpoint flash */
#cpFlash{
  position:fixed;inset:0;pointer-events:none;z-index:55;
  background:rgba(0,255,229,0.15);
  opacity:0;border:3px solid rgba(0,255,229,0.5);
  transition:opacity 0.1s;
}

#cpMsg{
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
  z-index:56;pointer-events:none;
  font-size:2.5rem;letter-spacing:6px;color:var(--cyan);
  text-shadow:0 0 30px var(--cyan);
  opacity:0;transition:opacity 0.2s;
}

/* Grab indicators */
#grabHints{
  position:fixed;bottom:70px;left:50%;transform:translateX(-50%);
  z-index:100;display:flex;gap:20px;pointer-events:none;
}

.grab-chip{
  background:rgba(5,3,10,0.9);
  border:1px solid rgba(255,107,0,0.4);
  border-radius:20px;padding:8px 18px;
  font-size:0.95rem;letter-spacing:3px;
  color:var(--gold);
  text-shadow:0 0 10px var(--gold);
  opacity:0;transform:translateY(8px);
  transition:opacity 0.2s,transform 0.2s;
}

.grab-chip.show{opacity:1;transform:translateY(0);}

/* Control strip */
#strip{
  position:fixed;bottom:18px;left:50%;transform:translateX(-50%);
  z-index:100;
  background:rgba(4,2,8,0.88);
  backdrop-filter:blur(16px);
  border:1px solid rgba(255,107,0,0.25);
  border-radius:40px;padding:10px 24px;
  display:none;align-items:center;gap:16px;
  font-family:'Share Tech Mono',monospace;
  font-size:0.7rem;color:#888;letter-spacing:1px;
  box-shadow:0 -2px 20px rgba(0,0,0,0.5);
}
#strip.show{display:flex;}

.sk{
  background:rgba(255,107,0,0.12);
  border:1px solid rgba(255,107,0,0.35);
  border-radius:4px;padding:2px 8px;
  color:#ccc;font-size:0.7rem;
}

/* â”€â”€â”€ PAUSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#pauseScreen{
  position:fixed;inset:0;z-index:190;
  background:rgba(5,3,10,0.92);
  backdrop-filter:blur(16px);
  display:none;align-items:center;justify-content:center;
}
#pauseScreen.show{display:flex;}

.pause-content{text-align:center;}
.pause-title{
  font-size:5rem;letter-spacing:8px;color:#fff;
  text-shadow:0 0 40px rgba(255,107,0,0.4);
  margin-bottom:12px;
}
.pause-sub{
  font-family:'Share Tech Mono',monospace;
  font-size:0.8rem;color:#555;letter-spacing:4px;
  margin-bottom:40px;
}

/* â”€â”€â”€ DEATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#deathScreen{
  position:fixed;inset:0;z-index:201;
  display:none;align-items:center;justify-content:center;
  background:rgba(5,3,10,0.97);
}
#deathScreen.show{display:flex;animation:deathFade 0.6s ease;}

@keyframes deathFade{from{opacity:0;transform:scale(1.03);}to{opacity:1;transform:scale(1);}}

.death-inner{text-align:center;max-width:500px;}

.death-title{
  font-size:clamp(3rem,8vw,5rem);
  letter-spacing:6px;
  color:var(--red);
  text-shadow:0 0 40px rgba(255,34,0,0.7),0 0 80px rgba(255,34,0,0.3);
  margin-bottom:8px;
  animation:deathPulse 2s ease infinite;
}

@keyframes deathPulse{
  0%,100%{text-shadow:0 0 40px rgba(255,34,0,0.7),0 0 80px rgba(255,34,0,0.3);}
  50%{text-shadow:0 0 60px rgba(255,34,0,1),0 0 120px rgba(255,34,0,0.5);}
}

.death-sub{
  font-family:'Share Tech Mono',monospace;
  font-size:0.8rem;color:#444;letter-spacing:3px;margin-bottom:40px;
}

.death-grid{
  display:grid;grid-template-columns:repeat(3,1fr);
  gap:12px;margin-bottom:40px;
}

.death-stat{
  background:rgba(255,34,0,0.06);
  border:1px solid rgba(255,34,0,0.2);
  border-radius:6px;padding:16px;
}

.death-stat-label{
  font-family:'Share Tech Mono',monospace;
  font-size:0.6rem;color:#555;letter-spacing:3px;
  margin-bottom:6px;
}

.death-stat-val{
  font-size:2rem;color:#fff;
  text-shadow:0 0 10px rgba(255,255,255,0.2);
}

.btn-row{display:flex;gap:12px;justify-content:center;}

.btn-retry{
  padding:14px 48px;
  background:linear-gradient(135deg,var(--red),var(--orange));
  border:none;border-radius:4px;
  color:#fff;font-family:'Bebas Neue',sans-serif;
  font-size:1.5rem;letter-spacing:4px;
  cursor:none;transition:all 0.25s;
  box-shadow:0 0 30px rgba(255,107,0,0.3);
}

.btn-retry:hover{
  transform:translateY(-2px);
  box-shadow:0 0 50px rgba(255,107,0,0.6);
}

.btn-menu{
  padding:14px 32px;
  background:transparent;
  border:1px solid rgba(255,107,0,0.4);
  border-radius:4px;
  color:#888;font-family:'Bebas Neue',sans-serif;
  font-size:1.5rem;letter-spacing:4px;
  cursor:none;transition:all 0.25s;
}

.btn-menu:hover{color:#fff;border-color:var(--orange);}

/* pointer lock */
#lockMsg{
  position:fixed;inset:0;z-index:189;
  background:rgba(5,3,10,0.9);backdrop-filter:blur(12px);
  display:none;align-items:center;justify-content:center;
  flex-direction:column;gap:12px;
  font-family:'Share Tech Mono',monospace;
  font-size:0.9rem;color:#aaa;letter-spacing:3px;text-align:center;
}
#lockMsg.show{display:flex;}
</style>
</head>
<body>

<div id="cursor"></div>
<div id="vignette"></div>
<div id="scanlines"></div>
<div id="chroma"></div>
<div id="flash"></div>
<div id="cpFlash"></div>
<div id="cpMsg">CHECKPOINT</div>

<!-- â”€â”€ MENU â”€â”€ -->
<div id="menu">
  <div class="menu-bg"></div>
  <div class="menu-grid"></div>
  <div class="menu-inner">
    <div class="menu-eyebrow">BAZOOKA STUDIO Â· PC EDITION</div>
    <div class="menu-title">CROWBAR<br><span>CLIMBERS</span></div>
    <div class="menu-sub">PHYSICS-BASED VERTICAL CLIMBING</div>

    <div class="menu-controls-grid">
      <div class="ctrl-card">
        <div class="ctrl-card-label">ğŸ”µ LEFT CROWBAR</div>
        <div class="ctrl-card-keys">
          Move: <b>W</b><b>A</b><b>S</b><b>D</b><br>
          Hook / Grab: <b>SHIFT</b>
        </div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">ğŸ”´ RIGHT CROWBAR</div>
        <div class="ctrl-card-keys">
          Move: <b>â†‘</b><b>â†</b><b>â†“</b><b>â†’</b><br>
          Hook / Grab: <b>ENTER</b>
        </div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">ğŸ“· CAMERA</div>
        <div class="ctrl-card-keys">
          Look: <b>MOUSE</b><br>
          Toggle 1st/3rd: <b>V</b>
        </div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">âš¡ TIPS</div>
        <div class="ctrl-card-keys">
          Swing both arms together for big launches. Don't let stamina hit zero!
        </div>
      </div>
    </div>

    <button class="play-btn" onclick="startGame()">START CLIMB</button>
    <div class="menu-tagline">4 STAGES Â· CHECKPOINTS Â· MOVING OBSTACLES Â· MOMENTUM PHYSICS</div>
  </div>
</div>

<!-- â”€â”€ PAUSE â”€â”€ -->
<div id="pauseScreen">
  <div class="pause-content">
    <div class="pause-title">PAUSED</div>
    <div class="pause-sub">PRESS ESC OR CLICK TO RESUME</div>
    <button class="play-btn" onclick="resumeGame()">RESUME</button>
  </div>
</div>

<!-- â”€â”€ DEATH â”€â”€ -->
<div id="deathScreen">
  <div class="death-inner">
    <div class="death-title">YOU FELL</div>
    <div class="death-sub">THE WALL WINS... FOR NOW</div>
    <div class="death-grid">
      <div class="death-stat">
        <div class="death-stat-label">MAX HEIGHT</div>
        <div class="death-stat-val" id="dHeight">0m</div>
      </div>
      <div class="death-stat">
        <div class="death-stat-label">TIME</div>
        <div class="death-stat-val" id="dTime">0:00</div>
      </div>
      <div class="death-stat">
        <div class="death-stat-label">GRABS</div>
        <div class="death-stat-val" id="dGrabs">0</div>
      </div>
    </div>
    <div class="btn-row">
      <button class="btn-retry" onclick="restartGame()">FULL RESTART</button>
      <button class="btn-retry" style="background:linear-gradient(135deg,#226644,#44AA66)" onclick="respawnAtCheckpoint()">â†© CHECKPOINT</button>
      <button class="btn-menu" onclick="showMenu()">MENU</button>
    </div>
  </div>
</div>

<!-- â”€â”€ LOCK MSG â”€â”€ -->
<div id="lockMsg">
  <div>CLICK ANYWHERE TO LOCK CURSOR</div>
  <div style="color:#444;font-size:0.7rem;letter-spacing:2px;">ESC TO PAUSE</div>
</div>

<!-- â”€â”€ HUD â”€â”€ -->
<div id="hud">
  <div class="hud-stat">
    <div class="hud-label">HEIGHT</div>
    <div class="hud-value" id="hHeight">0m</div>
  </div>
  <div class="hud-stat">
    <div class="hud-label">TIME</div>
    <div class="hud-value" id="hTime">0:00</div>
  </div>
  <div class="hud-stat">
    <div class="hud-label">GRABS</div>
    <div class="hud-value" id="hGrabs">0</div>
  </div>
  <div class="stamina-wrap">
    <div class="hud-label">STAMINA</div>
    <div class="stamina-track">
      <div class="stamina-bar" id="stBar" style="width:100%"></div>
    </div>
  </div>
  <div class="stage-badge">
    <div class="stage-name" id="stageName">FORGE DISTRICT</div>
    <div class="stage-progress" id="stageProgress">STAGE 1 / 4</div>
  </div>
</div>

<div id="grabHints">
  <div class="grab-chip" id="chipL">ğŸ”µ SHIFT TO GRAB</div>
  <div class="grab-chip" id="chipR">ğŸ”´ ENTER TO GRAB</div>
</div>

<div id="strip">
  <span>ğŸ”µ <span class="sk">WASD</span> <span class="sk">SHIFT</span></span>
  <span style="color:#333">|</span>
  <span>ğŸ”´ <span class="sk">ARROWS</span> <span class="sk">ENTER</span></span>
  <span style="color:#333">|</span>
  <span>ğŸ“· <span class="sk">MOUSE</span></span>
  <span style="color:#333">|</span>
  <span>ğŸ‘ <span class="sk">V</span> CAM</span>
  <span style="color:#333">|</span>
  <span><span class="sk">ESC</span> PAUSE</span>
</div>

<!-- Camera mode flash label -->
<div id="camModeLabel" style="
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
  z-index:110;pointer-events:none;
  font-size:1.8rem;letter-spacing:6px;
  color:#fff;text-shadow:0 0 20px rgba(255,107,0,0.8);
  opacity:0;transition:opacity 0.4s;
  font-family:'Bebas Neue',sans-serif;
">ğŸ¥ THIRD PERSON</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CROWBAR CLIMBERS â€“ PC EDITION
// AAA physics-based vertical climbing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const $ = id => document.getElementById(id);
const PI = Math.PI, TWO_PI = PI * 2;
const V3 = (x=0,y=0,z=0) => new THREE.Vector3(x,y,z);
const clamp = (v,mn,mx) => Math.max(mn, Math.min(mx,v));

// â”€â”€â”€ AUDIO ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AC = new (window.AudioContext || window.webkitAudioContext)();

function playSFX(freq, dur=0.1, type='square', vol=0.12, detune=0){
  try{
    const o = AC.createOscillator();
    const g = AC.createGain();
    const f = AC.createBiquadFilter();
    f.type='bandpass'; f.frequency.value=freq*2; f.Q.value=0.8;
    o.type=type; o.frequency.value=freq;
    if(detune) o.detune.value=detune;
    g.gain.value=vol;
    o.connect(f); f.connect(g); g.connect(AC.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+dur);
    setTimeout(()=>o.stop(), dur*1000+50);
  }catch(e){}
}

function playGrab(){ playSFX(300+Math.random()*120, 0.09, 'sawtooth', 0.18); }
function playFall(){ playSFX(80, 0.5, 'sawtooth', 0.2); playSFX(120, 0.3,'sine',0.12); }
function playCheckpoint(){ playSFX(880,0.15,'sine',0.2); setTimeout(()=>playSFX(1320,0.2,'sine',0.18),120); }
function playLow(){ playSFX(160+Math.random()*40,0.12,'sawtooth',0.1); }
function playSlip(){ playSFX(200,0.15,'sawtooth',0.15,-200); }

// â”€â”€â”€ CURSOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const cursor = $('cursor');
document.addEventListener('mousemove', e => {
  cursor.style.left = e.clientX+'px';
  cursor.style.top = e.clientY+'px';
});

// â”€â”€â”€ THREE SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let scene, camera, renderer;

function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x05030A, 0.008);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.05, 1200);
  camera.rotation.order = 'YXZ';

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
}

initThree();

// â”€â”€â”€ MATERIALS CACHE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAT = {
  crowbarMetal: new THREE.MeshPhysicalMaterial({
    color:0x222222, metalness:0.95, roughness:0.15, reflectivity:0.8
  }),
  holdRing: new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide})
};

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let G = null;

// Stage definitions
const STAGES = [
  { name:'FORGE DISTRICT',  yMin:0,   yMax:260,  color:0x1a0800, fog:0x0a0400, fogD:0.009, ambCol:0xFF6B00, ambInt:0.4, sunCol:0xFF6B00, sunInt:1.5, bgCol:0x08040A },
  { name:'MAGMA VAULT',     yMin:260, yMax:520,  color:0x1a0300, fog:0x120200, fogD:0.009, ambCol:0xFF2200, ambInt:0.5, sunCol:0xFF4400, sunInt:2.0, bgCol:0x0D0200 },
  { name:'NEON SPIRE',      yMin:520, yMax:780,  color:0x030A20, fog:0x020618, fogD:0.009, ambCol:0x9B4DFF, ambInt:0.5, sunCol:0x00FFE5, sunInt:1.8, bgCol:0x010208 },
  { name:'VOID ASCENT',     yMin:780, yMax:9999, color:0x000005, fog:0x000008, fogD:0.005, ambCol:0x4466FF, ambInt:0.3, sunCol:0x8888FF, sunInt:1.2, bgCol:0x000005 }
];

const HOLD_TYPES = ['sphere','pipe','slab','crystal'];
const ARM_LENGTH = 9.0;   // max arm extension
const GRAB_RADIUS = 11.0; // how close a hold must be to grab
const BODY_MASS  = 1.0;
const GRAVITY    = 0.22;
const DRAG       = 0.025;

// â”€â”€â”€ STAGE VISUAL SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ambientLight, sunLight, backLight, fillLight;

function setupLights(){
  ambientLight = new THREE.AmbientLight(0xFF6B00, 0.4);
  scene.add(ambientLight);

  sunLight = new THREE.DirectionalLight(0xFF6B00, 1.5);
  sunLight.position.set(20, 200, 30);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.set(2048,2048);
  sunLight.shadow.camera.left = -80;
  sunLight.shadow.camera.right = 80;
  sunLight.shadow.camera.top = 200;
  sunLight.shadow.camera.bottom = -30;
  sunLight.shadow.bias = -0.0003;
  scene.add(sunLight);

  backLight = new THREE.PointLight(0xFF2200, 1.2, 200);
  backLight.position.set(-20, 200, -40);
  scene.add(backLight);

  fillLight = new THREE.PointLight(0x6622FF, 0.6, 150);
  fillLight.position.set(30, 100, 20);
  scene.add(fillLight);
}

function updateStageLights(stageIdx){
  const s = STAGES[stageIdx];
  scene.fog.color.set(s.fog);
  scene.fog.density = s.fogD;
  renderer.setClearColor(s.bgCol);
  ambientLight.color.set(s.ambCol); ambientLight.intensity = s.ambInt;
  sunLight.color.set(s.sunCol); sunLight.intensity = s.sunInt;
}

// â”€â”€â”€ BACKGROUND / STARFIELD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildStarfield(){
  const geo = new THREE.BufferGeometry();
  const verts = [];
  for(let i=0;i<12000;i++){
    verts.push(
      (Math.random()-0.5)*2000,
      Math.random()*1200-50,
      (Math.random()-0.5)*2000
    );
  }
  geo.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  const mat = new THREE.PointsMaterial({color:0xffffff, size:1.8, transparent:true, opacity:0.85, sizeAttenuation:true});
  scene.add(new THREE.Points(geo, mat));
}

// â”€â”€â”€ MAIN WALL GEOMETRY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildWall(){
  // Background wall spans full height
  for(let y=0;y<200;y++){
    const geo = new THREE.BoxGeometry(60, 6.5, 2.5);
    const stageIdx = Math.floor(y / 40);
    const si = Math.min(stageIdx, STAGES.length-1);
    const mat = new THREE.MeshPhongMaterial({
      color: STAGES[si].color,
      emissive: STAGES[si].color,
      emissiveIntensity: 0.12,
      flatShading: true
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, y*6.5, -10);
    mesh.receiveShadow = true;
    scene.add(mesh);
  }

  // Vertical support columns
  for(let x = -4; x <= 4; x++){
    const geo = new THREE.CylinderGeometry(0.5, 0.5, 1300, 12);
    const mat = new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111, shininess:80});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x*7, 650, -10.5);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Stage divider beams
  for(const s of STAGES.slice(1)){
    const geo = new THREE.BoxGeometry(62, 1.5, 3);
    const mat = new THREE.MeshPhongMaterial({
      color:0x111111, emissive:0x220022, emissiveIntensity:0.5
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, s.yMin, -10);
    scene.add(mesh);

    // Glowing stage marker
    const gGeo = new THREE.BoxGeometry(62,0.3,0.3);
    const gMat = new THREE.MeshBasicMaterial({color:0xFF6B00});
    const gMesh = new THREE.Mesh(gGeo, gMat);
    gMesh.position.set(0, s.yMin+0.8, -8.5);
    scene.add(gMesh);
  }

  // Starting platform
  const pGeo = new THREE.BoxGeometry(24, 1.5, 8);
  const pMat = new THREE.MeshPhongMaterial({color:0x1a0a00, emissive:0x110800, shininess:20});
  const platform = new THREE.Mesh(pGeo, pMat);
  platform.position.set(0, -1, -5);
  platform.receiveShadow = true;
  platform.castShadow = true;
  scene.add(platform);

  // Platform glow edges
  const egGeo = new THREE.BoxGeometry(24, 0.2, 0.2);
  const egMat = new THREE.MeshBasicMaterial({color:0xFF6B00});
  const eg = new THREE.Mesh(egGeo, egMat);
  eg.position.set(0, -0.2, -1);
  scene.add(eg);
}

// â”€â”€â”€ HOLD CREATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function holdColor(stageIdx){
  const palettes = [
    [0xFF6B00, 0xFF9000, 0xFF4400, 0xFFCC00, 0xCC4400],
    [0xFF2200, 0xFF6600, 0xFF0000, 0xFF4422, 0xCC2200],
    [0x9B4DFF, 0x00FFE5, 0xFF00AA, 0x4499FF, 0xDD44FF],
    [0x4466FF, 0x8888FF, 0x44CCFF, 0xFFFFFF, 0x6688FF]
  ];
  const p = palettes[stageIdx] || palettes[0];
  return p[Math.floor(Math.random()*p.length)];
}

function createHold(x, y, z, type, stageIdx, moving=false){
  const group = new THREE.Group();
  const col = holdColor(stageIdx);
  const emMat = new THREE.MeshPhongMaterial({
    color:col, emissive:col, emissiveIntensity:0.6, shininess:100
  });

  let mainMesh;
  if(type==='sphere'){
    const geo = new THREE.SphereGeometry(0.85, 20, 20);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    // Eyes
    const eMat = new THREE.MeshBasicMaterial({color:0xffffff});
    const pupMat = new THREE.MeshBasicMaterial({color:0x000000});
    for(let side of [-1,1]){
      const e = new THREE.Mesh(new THREE.SphereGeometry(0.18,12,12), eMat);
      e.position.set(side*0.28, 0.1, 0.78);
      const p = new THREE.Mesh(new THREE.SphereGeometry(0.09,8,8), pupMat);
      p.position.set(side*0.28, 0.1, 0.89);
      group.add(e, p);
    }
  } else if(type==='pipe'){
    const geo = new THREE.CylinderGeometry(0.3, 0.3, 3.5, 16);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    mainMesh.rotation.z = PI/2;
    // End caps
    for(let s of [-1,1]){
      const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.2,16), emMat.clone());
      cap.rotation.z = PI/2;
      cap.position.x = s * 1.85;
      group.add(cap);
    }
  } else if(type==='slab'){
    const geo = new THREE.BoxGeometry(3.2, 0.55, 0.7);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    // Side brackets
    for(let s of [-1,1]){
      const bk = new THREE.Mesh(
        new THREE.BoxGeometry(0.25,0.8,0.8),
        new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111})
      );
      bk.position.x = s*1.7;
      group.add(bk);
    }
  } else { // crystal
    const geo = new THREE.OctahedronGeometry(0.9, 0);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    mainMesh.rotation.x = Math.random()*PI;
    mainMesh.rotation.z = Math.random()*PI;
  }

  mainMesh.castShadow = true;
  group.add(mainMesh);

  // Glow ring (shown when grabbable)
  const ringGeo = new THREE.TorusGeometry(1.4, 0.08, 16, 40);
  const ringMat = new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide});
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = PI/2;
  group.add(ring);

  group.position.set(x, y, z);
  group.userData = {
    type, col, grabbed:false, mainMesh, ring,
    moving, moveBase:new THREE.Vector3(x,y,z),
    moveAxis: moving?(['x','y'][Math.floor(Math.random()*2)]):'',
    moveAmp: 2+Math.random()*5,
    moveFreq: 0.3+Math.random()*0.7,
    movePhase: Math.random()*TWO_PI,
    stageIdx
  };

  scene.add(group);
  return group;
}

// â”€â”€â”€ CHECKPOINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createCheckpoint(y){
  const group = new THREE.Group();

  // Ring
  const ringGeo = new THREE.TorusGeometry(5, 0.25, 16, 60);
  const mat = new THREE.MeshBasicMaterial({color:0x00FFE5});
  const ring = new THREE.Mesh(ringGeo, mat);
  ring.rotation.x = PI/2;
  group.add(ring);

  // Inner glow ring
  const innerGeo = new THREE.TorusGeometry(4.6, 0.08, 16, 60);
  const innerMat = new THREE.MeshBasicMaterial({color:0x00FFE5, transparent:true, opacity:0.4});
  group.add(new THREE.Mesh(innerGeo, innerMat));

  // Flag poles
  for(let s of [-1,1]){
    const pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.12, 10, 8),
      new THREE.MeshPhongMaterial({color:0x666666})
    );
    pole.position.set(s*5.5, -5, 0);
    group.add(pole);

    const flag = new THREE.Mesh(
      new THREE.PlaneGeometry(1.8, 1.1),
      new THREE.MeshBasicMaterial({color:0x00FFE5, side:THREE.DoubleSide})
    );
    flag.position.set(s*5.5 + s*0.9, -0.5, 0);
    group.add(flag);
  }

  group.position.set(0, y, -3);
  group.userData = { triggered:false };
  scene.add(group);
  return group;
}

// â”€â”€â”€ MOVING OBSTACLE (GEAR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createGear(x, y, z, stageIdx){
  const group = new THREE.Group();
  const col = holdColor(stageIdx);

  // Outer ring
  const rGeo = new THREE.TorusGeometry(3.5, 0.35, 16, 60);
  const mat = new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111, shininess:80});
  const outer = new THREE.Mesh(rGeo, mat);
  group.add(outer);

  // Teeth (boxes around perimeter)
  const toothMat = new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:0.4});
  const TEETH = 12;
  for(let i=0;i<TEETH;i++){
    const a = (i/TEETH)*TWO_PI;
    const tooth = new THREE.Mesh(
      new THREE.BoxGeometry(0.8, 0.9, 0.6),
      toothMat
    );
    tooth.position.set(Math.cos(a)*3.7, Math.sin(a)*3.7, 0);
    tooth.rotation.z = a;
    group.add(tooth);
  }

  // Spokes
  for(let i=0;i<6;i++){
    const a = (i/6)*TWO_PI;
    const spoke = new THREE.Mesh(
      new THREE.BoxGeometry(7, 0.3, 0.3),
      new THREE.MeshPhongMaterial({color:0x555555})
    );
    spoke.rotation.z = a;
    group.add(spoke);
  }

  // Center bolt
  const bolt = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16),
    new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:0.8})
  );
  bolt.rotation.x = PI/2;
  group.add(bolt);

  group.position.set(x, y, z);
  group.userData = { type:'gear', rotSpeed: 0.008+Math.random()*0.012, dir:Math.random()<0.5?1:-1 };
  scene.add(group);
  return group;
}

// â”€â”€â”€ PARTICLE SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const particles = [];

function spawnParticles(pos, col, count=8, speed=0.15){
  for(let i=0;i<count;i++){
    const geo = new THREE.SphereGeometry(0.1, 4, 4);
    const mat = new THREE.MeshBasicMaterial({color:col, transparent:true, opacity:1});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    particles.push({
      mesh, life:1.0,
      vel: V3((Math.random()-0.5)*speed*2, Math.random()*speed+0.05, (Math.random()-0.5)*speed)
    });
  }
}

function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= 0.04;
    p.vel.y -= 0.008;
    p.mesh.position.add(p.vel);
    p.mesh.material.opacity = p.life;
    p.mesh.scale.setScalar(p.life*0.8+0.2);
    if(p.life<=0){
      scene.remove(p.mesh);
      particles.splice(i,1);
    }
  }
}

// â”€â”€â”€ HAND / CROWBAR OBJECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createHandObject(col, label){
  const group = new THREE.Group();

  // BIG bold cartoon blob body â€” matches the reference (large flat sphere)
  const bodyMat = new THREE.MeshPhongMaterial({
    color:col, emissive:col, emissiveIntensity:0.45, shininess:30
  });
  const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), bodyMat);
  body.castShadow = true;
  group.add(body);

  // Flat white dot eyes (CircleGeometry facing forward â€” clean 2D look)
  const whiteMat = new THREE.MeshBasicMaterial({color:0xFFFFFF, side:THREE.FrontSide});
  const pupilMat = new THREE.MeshBasicMaterial({color:0x111111, side:THREE.FrontSide});
  for(let s of [-1,1]){
    // white sclera
    const white = new THREE.Mesh(new THREE.CircleGeometry(0.32, 24), whiteMat);
    white.position.set(s*0.5, 0.2, 1.44);
    group.add(white);
    // dark pupil
    const pupil = new THREE.Mesh(new THREE.CircleGeometry(0.16, 16), pupilMat);
    pupil.position.set(s*0.5, 0.2, 1.46);
    group.add(pupil);
  }

  // Crowbar â€” thin dark metal shaft
  const shaftMat = new THREE.MeshPhongMaterial({color:0x2a2a2a, emissive:0x111111, shininess:100});
  const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5.5, 12), shaftMat);
  shaft.position.set(0, 4.25, 0);
  shaft.castShadow = true;
  group.add(shaft);

  // Hook curve
  const hook = new THREE.Mesh(
    new THREE.TorusGeometry(0.4, 0.09, 10, 24, PI*1.15),
    shaftMat
  );
  hook.position.set(0, 7.0, 0);
  hook.rotation.x = PI/2;
  group.add(hook);

  // Spike tip
  const tip = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.4, 8), shaftMat);
  tip.position.set(0.4, 7.35, 0);
  tip.rotation.z = -PI/2;
  group.add(tip);

  // Grab glow ring â€” visible when latched on
  const glowMat = new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide});
  const glow = new THREE.Mesh(new THREE.TorusGeometry(1.9, 0.08, 12, 40), glowMat);
  glow.rotation.x = PI/2;
  group.add(glow);

  group.userData = { glow, bodyMat, label };
  scene.add(group);

  return {
    group,
    pos: V3(),
    vel: V3(),
    hooked: false,
    hookHold: null,
    nearHold: null,
    swingMom: V3()
  };
}

// â”€â”€â”€ PLAYER BODY OBJECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createPlayerBody(){
  const group = new THREE.Group();

  // Torso
  const torsoGeo = new THREE.CylinderGeometry(0.55, 0.55, 1.2, 16);
  const torsoMat = new THREE.MeshPhongMaterial({color:0x222244, emissive:0x111122, shininess:60});
  const torso = new THREE.Mesh(torsoGeo, torsoMat);
  torso.castShadow = true;
  group.add(torso);

  // Head
  const headGeo = new THREE.SphereGeometry(0.52, 20, 20);
  const headMat = new THREE.MeshPhongMaterial({color:0xFFCC99, emissive:0x221100, shininess:80});
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.set(0, 1.3, 0);
  head.castShadow = true;
  group.add(head);

  // Eyes
  const eMat = new THREE.MeshBasicMaterial({color:0x111111});
  for(let s of [-1,1]){
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), eMat);
    eye.position.set(s*0.2, 1.38, 0.46);
    group.add(eye);
  }

  // Hard hat
  const hatBrimGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.1, 16);
  const hatTopGeo  = new THREE.SphereGeometry(0.5, 16, 8, 0, TWO_PI, 0, PI/2);
  const hatMat = new THREE.MeshPhongMaterial({color:0xFFCC00, emissive:0x664400, emissiveIntensity:0.3});
  const hatBrim = new THREE.Mesh(hatBrimGeo, hatMat);
  hatBrim.position.set(0, 1.72, 0);
  const hatTop = new THREE.Mesh(hatTopGeo, hatMat);
  hatTop.position.set(0, 1.73, 0);
  group.add(hatBrim, hatTop);

  // Legs (2 cylinders)
  for(let s of [-1,1]){
    const leg = new THREE.Mesh(
      new THREE.CylinderGeometry(0.2, 0.18, 1.0, 10),
      new THREE.MeshPhongMaterial({color:0x1a1a3a})
    );
    leg.position.set(s*0.25, -1.1, 0);
    group.add(leg);

    // Boots
    const boot = new THREE.Mesh(
      new THREE.BoxGeometry(0.32, 0.22, 0.55),
      new THREE.MeshPhongMaterial({color:0x553300})
    );
    boot.position.set(s*0.25, -1.67, 0.1);
    group.add(boot);
  }

  scene.add(group);
  return group;
}

// â”€â”€â”€ ARM ROPE LINES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createArmLines(){
  const mat = new THREE.LineBasicMaterial({
    color:0x888888, transparent:true, opacity:0.7, linewidth:1
  });

  function makeLine(){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0,0,0,0], 3));
    const line = new THREE.Line(geo, mat.clone());
    scene.add(line);
    return line;
  }

  return { left: makeLine(), right: makeLine() };
}

function updateArmLine(line, fromPos, toPos){
  const pos = line.geometry.attributes.position;
  pos.setXYZ(0, fromPos.x, fromPos.y, fromPos.z);
  pos.setXYZ(1, toPos.x, toPos.y, toPos.z);
  pos.needsUpdate = true;
}

// â”€â”€â”€ GAME START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame(){
  $('menu').classList.add('hide');
  $('hud').classList.add('show');
  $('strip').classList.add('show');

  // Resume AudioContext if needed
  if(AC.state==='suspended') AC.resume();

  // Clear old scene objects
  if(G){
    scene.children.slice().forEach(c=>{
      if(c.type!=='Points') scene.remove(c);
    });
  }

  setupLights();
  buildStarfield();
  buildWall();

  G = {
    phase:'playing',
    camYaw: 0,
    camPitch: -0.1,
    camDist: 14,
    camTargetY: 10,
    camMode: 'third', // 'third' or 'first'
    fpYaw: 0,         // first-person yaw
    fpPitch: 0.6,     // first-person pitch (looking up by default)
    mouseX: 0,
    mouseY: 0,
    keys: {},

    body: {
      pos: V3(0, 8, 2),
      vel: V3(),
      onGround: false
    },

    left:  null,
    right: null,

    holds: [],
    gears: [],
    checkpoints: [],
    checkpointIdx: 0,
    respawnPos: V3(0, 8, 2),

    stamina: 100,
    grabs: 0,
    maxHeight: 0,
    startTime: Date.now(),

    screenShake: 0,
    stageIdx: 0,
    dead: false,
    paused: false
  };

  // Create hands
  G.left  = createHandObject(0x4488FF, 'L');
  G.right = createHandObject(0xFF3366, 'R');
  G.playerBody = createPlayerBody();
  G.armLines = createArmLines();

  // Ambient rain/lava particles
  G.envParticles = [];

  G.left.pos.set(-2.5, 10, 2);
  G.right.pos.set(2.5, 10, 2);
  G.left.group.position.copy(G.left.pos);
  G.right.group.position.copy(G.right.pos);

  // â”€ Generate holds procedurally â”€
  generateHolds();

  // â”€ Request pointer lock â”€
  renderer.domElement.requestPointerLock();

  updateStageLights(0);
  renderer.setClearColor(0x08040A);

  requestAnimationFrame(gameLoop);
}

function generateHolds(){
  // Create holds in clusters along a climbable path
  // Each "band" at certain height has a cluster of 3-5 holds within reach
  const TOTAL_HEIGHT = 900;
  const BAND_HEIGHT = 7;   // tighter vertical bands = more holds in reach
  const numBands = Math.floor(TOTAL_HEIGHT / BAND_HEIGHT);

  let prevClusterX = 0;

  for(let b=0; b<numBands; b++){
    const baseY = 15 + b * BAND_HEIGHT;
    const stageIdx = Math.min(STAGES.findIndex(s=>baseY>=s.yMin && baseY<s.yMax), STAGES.length-1);
    const safeStage = stageIdx < 0 ? STAGES.length-1 : stageIdx;

    const numHolds = 3 + Math.floor(Math.random()*3); // more holds per band
    // Cluster drifts gently so there's always something reachable
    const clusterX = clamp(prevClusterX + (Math.random()-0.5)*8, -14, 14);
    prevClusterX = clusterX;

    for(let h=0; h<numHolds; h++){
      const x = clusterX + (Math.random()-0.5)*10; // tighter X spread
      const y = baseY + (Math.random()-0.3)*BAND_HEIGHT*0.9;
      const z = -7 + Math.random()*2;  // closer to camera/player
      const type = HOLD_TYPES[Math.floor(Math.random()*HOLD_TYPES.length)];

      const movingChance = safeStage * 0.12;
      const moving = Math.random() < movingChance;

      const hold = createHold(x, y, z, type, safeStage, moving);
      G.holds.push(hold);
    }

    // Add gear obstacles every 50m from stage 2+
    if(b>0 && b%8===0 && safeStage>=1){
      const gx = (Math.random()-0.5)*30;
      const g = createGear(gx, baseY-3, -8, safeStage);
      G.gears.push(g);
    }
  }

  // Checkpoints every 130 units
  for(let y=120; y<TOTAL_HEIGHT; y+=130){
    const cp = createCheckpoint(y);
    G.checkpoints.push(cp);
  }
}

// â”€â”€â”€ POINTER LOCK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('pointerlockchange', ()=>{
  if(document.pointerLockElement === renderer.domElement){
    $('lockMsg').classList.remove('show');
    if(G && G.paused) resumeGame();
  } else if(G && !G.dead && !G.paused && G.phase==='playing'){
    G.paused = true;
    $('pauseScreen').classList.add('show');
  }
});

renderer.domElement.addEventListener('click', ()=>{
  if(G && !G.dead && !document.pointerLockElement){
    renderer.domElement.requestPointerLock();
  }
});

document.addEventListener('mousemove', e=>{
  if(!G || G.paused || G.dead) return;
  if(document.pointerLockElement === renderer.domElement){
    G.mouseX += e.movementX || 0;
    G.mouseY += e.movementY || 0;
  }
});

// â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e=>{
  if(!G) return;
  G.keys[e.key] = true;
  G.keys[e.code] = true;

  if(e.key === 'Shift'){
    e.preventDefault();
    tryGrab(G.left);
  }
  if(e.key === 'Enter'){
    e.preventDefault();
    tryGrab(G.right);
  }
  if(e.key === 'Escape'){
    if(!G.dead){
      G.paused ? resumeGame() : pauseGame();
    }
  }
  if((e.key === 'v' || e.key === 'V') && G.phase==='playing'){
    G.camMode = G.camMode==='third' ? 'first' : 'third';
    $('camModeLabel').textContent = G.camMode==='first' ? 'ğŸ‘ FIRST PERSON' : 'ğŸ¥ THIRD PERSON';
    $('camModeLabel').style.opacity = '1';
    clearTimeout(G._camLabelTimer);
    G._camLabelTimer = setTimeout(()=>{ $('camModeLabel').style.opacity='0'; }, 2000);
  }
});

document.addEventListener('keyup', e=>{
  if(!G) return;
  G.keys[e.key] = false;
  G.keys[e.code] = false;

  if(e.key === 'Shift') releaseGrab(G.left);
  if(e.key === 'Enter') releaseGrab(G.right);
});

function pauseGame(){
  G.paused = true;
  document.exitPointerLock();
  $('pauseScreen').classList.add('show');
}

function resumeGame(){
  G.paused = false;
  $('pauseScreen').classList.remove('show');
  renderer.domElement.requestPointerLock();
}

// â”€â”€â”€ GRAB LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tryGrab(hand){
  if(hand.hooked || G.stamina < 4) return;

  // Find closest ungrabbed hold
  let best = null, bestDist = GRAB_RADIUS;
  for(const h of G.holds){
    if(h.userData.grabbed) continue;
    const d = hand.pos.distanceTo(h.position);
    if(d < bestDist){ best=h; bestDist=d; }
  }

  if(best){
    hand.hooked = true;
    hand.hookHold = best;
    best.userData.grabbed = true;
    best.userData.ring.material.opacity = 1.0;
    hand.group.userData.glow.material.opacity = 0.9;

    // Transfer momentum
    const dir = V3().subVectors(best.position, hand.pos).normalize();
    hand.swingMom.copy(dir).multiplyScalar(2.5);

    G.grabs++;
    playGrab();
    spawnParticles(hand.pos, best.userData.col, 10, 0.18);
    $('flash').style.opacity=0.25;
    setTimeout(()=>$('flash').style.opacity=0, 100);
  } else {
    playSlip();
  }
}

function releaseGrab(hand){
  if(!hand.hooked) return;
  if(hand.hookHold){
    hand.hookHold.userData.grabbed = false;
    hand.hookHold.userData.ring.material.opacity = 0;
    hand.hookHold = null;
  }
  hand.hooked = false;
  hand.group.userData.glow.material.opacity = 0;
}

// â”€â”€â”€ PHYSICS UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updatePhysics(dt){
  const stageIdx = G.stageIdx;
  const lowGrav = stageIdx >= 3; // void ascent
  const grav = lowGrav ? GRAVITY * 0.35 : GRAVITY;

  const lGrabbed = G.left.hooked;
  const rGrabbed = G.right.hooked;

  // â”€ Body gravity â”€
  if(!lGrabbed && !rGrabbed){
    G.body.vel.y -= grav;
  } else if(lGrabbed && rGrabbed){
    G.body.vel.y *= 0.88;
    G.body.vel.x *= 0.92;
    G.body.vel.z *= 0.92;
  } else {
    G.body.vel.y -= grav * 0.3;
  }

  G.body.vel.multiplyScalar(1-DRAG);
  G.body.pos.add(G.body.vel);

  // â”€ Body constraints from hands â”€
  for(const hand of [G.left, G.right]){
    if(!hand.hooked) continue;
    const hPos = hand.hookHold.position;
    const toBody = V3().subVectors(G.body.pos, hPos);
    const dist = toBody.length();
    if(dist > ARM_LENGTH){
      const normal = toBody.normalize();
      G.body.pos.copy(hPos).addScaledVector(normal, ARM_LENGTH);
      const vdot = G.body.vel.dot(normal);
      if(vdot > 0) G.body.vel.addScaledVector(normal, -vdot * 1.1);
    }
  }

  // â”€ Ground constraint â”€
  if(G.body.pos.y < 0){
    G.body.pos.y = 0;
    if(G.body.vel.y < -8){
      G.screenShake = Math.min(1.5, -G.body.vel.y * 0.05);
      playLow();
    }
    G.body.vel.y = Math.max(0, G.body.vel.y);
    G.body.vel.x *= 0.8;
    G.body.vel.z *= 0.8;
    G.body.onGround = true;
  } else {
    G.body.onGround = false;
  }

  // â”€ Update hand positions â”€
  updateHand(G.left,  'w','s','a','d', lGrabbed, rGrabbed, grav);
  updateHand(G.right, 'ArrowUp','ArrowDown','ArrowLeft','ArrowRight', rGrabbed, lGrabbed, grav);

  // â”€ Stamina â”€
  const drainingStam = lGrabbed || rGrabbed;
  if(drainingStam){
    const drain = (lGrabbed && rGrabbed) ? 0.06 : 0.11;
    G.stamina = Math.max(0, G.stamina - drain);
    if(G.stamina === 0){
      if(lGrabbed){ releaseGrab(G.left); playSlip(); }
      if(rGrabbed){ releaseGrab(G.right); playSlip(); }
    }
  } else {
    G.stamina = Math.min(100, G.stamina + 0.18);
  }

  // â”€ Death: fell off bottom â”€
  const fallThreshold = G.respawnPos.y - 120;
  if(G.body.pos.y < fallThreshold && !G.body.onGround){
    die();
    return;
  }

  // â”€ Max height â”€
  G.maxHeight = Math.max(G.maxHeight, Math.floor(G.body.pos.y));

  // â”€ Moving holds â”€
  const t = Date.now() * 0.001;
  for(const h of G.holds){
    if(!h.userData.moving) continue;
    const ud = h.userData;
    const offset = Math.sin(t * ud.moveFreq + ud.movePhase) * ud.moveAmp;
    if(ud.moveAxis==='x') h.position.x = ud.moveBase.x + offset;
    else h.position.y = ud.moveBase.y + offset;
    // If hand is hooked to this hold, update hooked position
    for(const hand of [G.left, G.right]){
      if(hand.hooked && hand.hookHold===h){
        // body will be reconstrained next frame
      }
    }
  }

  // â”€ Rotate gears â”€
  for(const g of G.gears){
    g.rotation.z += g.userData.rotSpeed * g.userData.dir;
  }

  // â”€ Update arm lines â”€
  if(G.left.hooked && G.left.hookHold){
    updateArmLine(G.armLines.left, G.body.pos, G.left.hookHold.position);
    G.armLines.left.material.opacity = 0.8;
  } else {
    updateArmLine(G.armLines.left, G.body.pos, G.left.pos);
    G.armLines.left.material.opacity = 0.35;
  }
  if(G.right.hooked && G.right.hookHold){
    updateArmLine(G.armLines.right, G.body.pos, G.right.hookHold.position);
    G.armLines.right.material.opacity = 0.8;
  } else {
    updateArmLine(G.armLines.right, G.body.pos, G.right.pos);
    G.armLines.right.material.opacity = 0.35;
  }

  // â”€ Update player body mesh â”€
  G.playerBody.position.lerp(G.body.pos, 0.25);
  G.playerBody.rotation.y += (G.body.vel.x * 0.3 - G.playerBody.rotation.y) * 0.1;
  const tiltZ = -G.body.vel.x * 0.15;
  G.playerBody.rotation.z += (tiltZ - G.playerBody.rotation.z) * 0.12;

  // â”€ Launch mechanic: both hooked + both down keys = BOOST â”€
  if(G.left.hooked && G.right.hooked &&
     G.keys['s'] && G.keys['ArrowDown']){
    const avgHoldY = (G.left.hookHold.position.y + G.right.hookHold.position.y)*0.5;
    const launchDir = V3(0,1,0);
    G.body.vel.addScaledVector(launchDir, 0.8);
    G.body.vel.y = Math.max(G.body.vel.y, 4.5);
    releaseGrab(G.left);
    releaseGrab(G.right);
    G.screenShake = 0.4;
    spawnParticles(G.body.pos, 0xFFD000, 15, 0.25);
    playSFX(600, 0.15, 'sine', 0.25);
    playSFX(300, 0.1, 'sawtooth', 0.15);
  }

  // â”€ Ambient environment particles â”€
  updateEnvParticles();

  // â”€ Checkpoints â”€
  for(const cp of G.checkpoints){
    if(cp.userData.triggered) continue;
    if(Math.abs(G.body.pos.y - cp.position.y) < 4 &&
       Math.abs(G.body.pos.x - cp.position.x) < 5){
      cp.userData.triggered = true;
      G.respawnPos = V3(0, cp.position.y+3, 2);
      G.checkpointIdx++;
      playCheckpoint();
      showCheckpointFlash();
    }
  }

  // â”€ Stage change â”€
  const newStage = Math.min(STAGES.length-1, STAGES.findIndex(s=>G.body.pos.y>=s.yMin && G.body.pos.y<s.yMax));
  const si = newStage < 0 ? STAGES.length-1 : newStage;
  if(si !== G.stageIdx){
    G.stageIdx = si;
    updateStageLights(si);
    sunLight.position.y = G.body.pos.y + 100;
    backLight.position.y = G.body.pos.y + 80;
  }
}

// â”€â”€â”€ ENVIRONMENT PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateEnvParticles(){
  if(!G.envParticles) return;
  const si = G.stageIdx;
  const bp = G.body.pos;

  if(si===1 && Math.random()<0.25){ // Volcanic sparks
    spawnParticles(V3(bp.x+(Math.random()-0.5)*25, bp.y+(Math.random()-0.5)*20, -8+Math.random()*5), 0xFF4400, 3, 0.2);
  }
  if(si===2 && Math.random()<0.2){ // Neon rain
    const x = bp.x+(Math.random()-0.5)*40;
    const y = bp.y+18+Math.random()*8;
    const z = bp.z+(Math.random()-0.5)*5;
    const geo = new THREE.CylinderGeometry(0.03,0.03,0.8,4);
    const col = Math.random()<0.5?0x9B4DFF:0x00FFE5;
    const mat = new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.8});
    const drop = new THREE.Mesh(geo,mat);
    drop.position.set(x,y,z);
    scene.add(drop);
    G.envParticles.push({mesh:drop,life:1.0,vel:V3(0,-0.8,0)});
  }
  if(si===3 && Math.random()<0.12){ // Space debris
    const x = bp.x+(Math.random()-0.5)*60;
    const y = bp.y+(Math.random()-0.5)*30;
    const col = Math.random()<0.5?0x4466FF:0x8888FF;
    const geo = new THREE.BoxGeometry(0.3,0.3,0.3);
    const mat = new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.6});
    const d = new THREE.Mesh(geo,mat);
    d.position.set(x,y,-20+Math.random()*10);
    scene.add(d);
    G.envParticles.push({mesh:d,life:1.0,vel:V3((Math.random()-0.5)*0.05,-0.02,0)});
  }

  for(let i=G.envParticles.length-1;i>=0;i--){
    const p = G.envParticles[i];
    p.life -= 0.012;
    p.mesh.position.add(p.vel);
    p.mesh.material.opacity = p.life*0.8;
    if(p.life<=0||Math.abs(p.mesh.position.y-bp.y)>35){
      scene.remove(p.mesh);
      G.envParticles.splice(i,1);
    }
  }
}


function updateHand(hand, ku, kd, kl, kr, isHooked, otherHooked, grav){
  const speed = isHooked ? 0.12 : 0.28; // much faster

  if(!isHooked){
    if(G.keys[ku]) hand.vel.y += speed;
    if(G.keys[kd]) hand.vel.y -= speed;
    if(G.keys[kl]) hand.vel.x -= speed;
    if(G.keys[kr]) hand.vel.x += speed;

    // Very light gravity on free hand so it floats up easily
    hand.vel.y -= grav * 0.15;
    hand.vel.multiplyScalar(0.84);

    hand.pos.add(hand.vel);
    hand.pos.add(hand.swingMom);
    hand.swingMom.multiplyScalar(0.93);

    // Wide reach bounds â€” let arms go far above
    hand.pos.x = clamp(hand.pos.x, -28, 28);
    hand.pos.y = clamp(hand.pos.y, G.body.pos.y-3, G.body.pos.y+22);
    hand.pos.z = clamp(hand.pos.z, -8, 10);
  } else {
    // Hooked: lerp to hold position
    const hp = hand.hookHold.position;
    hand.pos.lerp(hp, 0.3);
    hand.vel.set(0,0,0);

    // Move with WASD/arrows as micro-adjustments
    if(G.keys[ku]) G.body.vel.y += 0.04;
    if(G.keys[kd]) G.body.vel.y -= 0.015;
    if(G.keys[kl]) G.body.vel.x -= 0.03;
    if(G.keys[kr]) G.body.vel.x += 0.03;
  }

  hand.group.position.lerp(hand.pos, 0.35);

  // Orient crowbar toward hook point or forward
  if(isHooked && hand.hookHold){
    const target = hand.hookHold.position.clone().sub(hand.pos).normalize();
    const angle = Math.atan2(target.x, target.y);
    hand.group.rotation.z = -angle * 0.5;
    hand.group.rotation.y = Math.atan2(-target.x, target.z) * 0.3;
  } else {
    hand.group.rotation.z *= 0.9;
    hand.group.rotation.y *= 0.9;
  }

  hand.group.rotation.x = Math.sin(Date.now()*0.002) * 0.05;

  // Detect nearby holds
  hand.nearHold = null;
  let nearDist = GRAB_RADIUS;
  for(const h of G.holds){
    if(h.userData.grabbed) continue;
    const d = hand.pos.distanceTo(h.position);
    if(d < nearDist){ hand.nearHold = h; nearDist = d; }
  }
}

// â”€â”€â”€ CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCamera(){
  const sens = 0.0018;

  // Screen shake
  const shake = G.screenShake;
  const sx = (Math.random()-0.5)*shake*0.4;
  const sy = (Math.random()-0.5)*shake*0.4;
  G.screenShake *= 0.88;

  if(G.camMode === 'first'){
    // â”€â”€ FIRST PERSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Mouse look in first person
    G.fpYaw   -= G.mouseX * sens;
    G.fpPitch -= G.mouseY * sens;
    // Pitch range: looking mostly upward (0.2 = slight up, 1.4 = straight up, PI*0.48 = almost behind)
    G.fpPitch = clamp(G.fpPitch, -0.1, PI * 0.48);
    G.mouseX = 0; G.mouseY = 0;

    // Camera sits at character head position
    camera.position.set(
      G.body.pos.x + sx,
      G.body.pos.y + 2.0 + sy,  // eye level
      G.body.pos.z + 1.5        // slightly in front of body
    );

    camera.rotation.order = 'YXZ';
    camera.rotation.y = G.fpYaw;
    camera.rotation.x = G.fpPitch;  // positive = looking up

    // Hide the player body mesh in first person so it doesn't block view
    if(G.playerBody) G.playerBody.visible = false;

  } else {
    // â”€â”€ THIRD PERSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    G.camYaw   -= G.mouseX * sens;
    G.camPitch -= G.mouseY * sens;
    G.camPitch  = clamp(G.camPitch, -PI*0.4, PI*0.35);
    G.mouseX = 0; G.mouseY = 0;

    G.camTargetY += (G.body.pos.y - G.camTargetY) * 0.08;

    const cy = G.camYaw;
    const cp = G.camPitch;
    const dist = G.camDist;

    camera.position.set(
      G.body.pos.x + Math.sin(cy)*Math.cos(cp)*dist + sx,
      G.camTargetY + Math.sin(cp)*dist + 2 + sy,
      G.body.pos.z + Math.cos(cy)*Math.cos(cp)*dist
    );

    camera.rotation.order = 'YXZ';
    camera.rotation.y = cy;
    camera.rotation.x = cp;

    if(G.playerBody) G.playerBody.visible = true;
  }

  // Moving lights follow player
  sunLight.position.set(20, G.body.pos.y+120, 30);
  backLight.position.set(-25, G.body.pos.y+80, -40);
  fillLight.position.set(30, G.body.pos.y+50, 30);
}

// â”€â”€â”€ HUD UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHUD(){
  $('hHeight').textContent = G.maxHeight+'m';
  $('hGrabs').textContent = G.grabs;

  const t = (Date.now()-G.startTime)/1000;
  const m = Math.floor(t/60);
  const s = Math.floor(t%60).toString().padStart(2,'0');
  $('hTime').textContent = `${m}:${s}`;

  const bar = $('stBar');
  bar.style.width = G.stamina+'%';
  bar.classList.toggle('low', G.stamina < 22);

  const si = G.stageIdx;
  $('stageName').textContent = STAGES[si].name;
  $('stageProgress').textContent = `STAGE ${si+1} / 4`;

  // Grab hints
  $('chipL').classList.toggle('show', !!G.left.nearHold && !G.left.hooked);
  $('chipR').classList.toggle('show', !!G.right.nearHold && !G.right.hooked);
}

// â”€â”€â”€ CHECKPOINT FLASH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showCheckpointFlash(){
  const cf = $('cpFlash');
  const cm = $('cpMsg');
  cf.style.opacity=1; cm.style.opacity=1;
  setTimeout(()=>{ cf.style.opacity=0; cm.style.opacity=0; }, 1200);
}

// â”€â”€â”€ DEATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function die(){
  G.dead = true;
  G.phase = 'dead';
  document.exitPointerLock();
  $('hud').classList.remove('show');
  $('strip').classList.remove('show');

  $('dHeight').textContent = G.maxHeight+'m';
  const t = (Date.now()-G.startTime)/1000;
  $('dTime').textContent = `${Math.floor(t/60)}:${Math.floor(t%60).toString().padStart(2,'0')}`;
  $('dGrabs').textContent = G.grabs;

  $('deathScreen').classList.add('show');
  playFall();
  G.screenShake = 2.5;
}

function restartGame(){
  $('deathScreen').classList.remove('show');
  // Remove all scene objects
  scene.children.slice().forEach(c=>scene.remove(c));
  G = null;
  startGame();
}

function respawnAtCheckpoint(){
  // Respawn from last checkpoint without full restart
  G.dead = false;
  G.phase = 'playing';
  G.body.pos.copy(G.respawnPos);
  G.body.vel.set(0,0,0);
  G.left.pos.copy(G.respawnPos).add(V3(-2.5,2,0));
  G.right.pos.copy(G.respawnPos).add(V3(2.5,2,0));
  G.left.hooked = false; G.left.hookHold = null;
  G.right.hooked = false; G.right.hookHold = null;
  G.stamina = 100;
  G.screenShake = 0;
  $('deathScreen').classList.remove('show');
  $('hud').classList.add('show');
  $('strip').classList.add('show');
  renderer.domElement.requestPointerLock();
}

function showMenu(){
  $('deathScreen').classList.remove('show');
  $('hud').classList.remove('show');
  $('strip').classList.remove('show');
  $('menu').classList.remove('hide');
  scene.children.slice().forEach(c=>scene.remove(c));
  G = null;
}

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = 0;

function gameLoop(ts=0){
  requestAnimationFrame(gameLoop);
  const dt = Math.min((ts-lastTime)/16.67, 3);
  lastTime = ts;

  if(!G){ renderer.render(scene, camera); return; }
  if(G.paused || G.dead){ renderer.render(scene, camera); return; }

  updatePhysics(dt);
  updateCamera();
  updateParticles();
  updateHUD();

  // Pulsing holds
  const t = Date.now() * 0.002;
  for(const h of G.holds){
    const pulse = 0.5 + Math.sin(t + h.position.y*0.1)*0.5;
    if(h.userData.light) h.userData.light.intensity = 0.5 + pulse*0.6;
  }

  renderer.render(scene, camera);
}

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
buildStarfield();
renderer.setClearColor(0x05030A);
renderer.render(scene, camera);

// Animate menu starfield
(function menuLoop(){
  if(G) return;
  requestAnimationFrame(menuLoop);
  renderer.render(scene, camera);
  scene.children.forEach(c=>{ if(c.type==='Points') c.rotation.y+=0.0002; });
})();

</script>
</body>
</html>

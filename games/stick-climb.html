<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STICK CLIMB</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
:root{
  --c1:#7B4FFF;--c2:#00D4FF;--c3:#FF6B35;--c4:#FF2255;
  --gold:#FFD000;--dark:#03020A;
}
body{background:#000;overflow:hidden;font-family:'Orbitron',sans-serif;cursor:none;}
canvas{display:block;}

#cursor{position:fixed;width:12px;height:12px;border:1.5px solid var(--c2);border-radius:50%;
  pointer-events:none;z-index:9999;transform:translate(-50%,-50%);
  background:rgba(0,212,255,0.1);box-shadow:0 0 8px var(--c2);}
#cursor::after{content:'';position:absolute;top:50%;left:50%;width:3px;height:3px;
  background:var(--c2);border-radius:50%;transform:translate(-50%,-50%);}

#vignette{position:fixed;inset:0;pointer-events:none;z-index:50;
  background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.92) 100%);}
#scanlines{position:fixed;inset:0;pointer-events:none;z-index:51;
  background:repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(0,0,0,0.05) 3px,rgba(0,0,0,0.05) 6px);opacity:0.3;}
#flash{position:fixed;inset:0;pointer-events:none;z-index:53;
  background:rgba(123,79,255,0.4);opacity:0;transition:opacity 0.05s;}
#chroma{position:fixed;inset:0;pointer-events:none;z-index:52;opacity:0;}
#cpFlash{position:fixed;inset:0;pointer-events:none;z-index:55;
  background:rgba(0,212,255,0.1);opacity:0;border:2px solid rgba(0,212,255,0.4);transition:opacity 0.15s;}
#cpMsg{position:fixed;top:42%;left:50%;transform:translate(-50%,-50%);z-index:56;
  pointer-events:none;font-size:1.4rem;letter-spacing:8px;color:var(--c2);
  text-shadow:0 0 30px var(--c2);opacity:0;transition:opacity 0.2s;font-weight:700;}

/* MENU */
#menu{position:fixed;inset:0;z-index:200;display:flex;align-items:center;
  justify-content:center;background:var(--dark);}
#menu.hide{display:none;}
.menu-bg{position:absolute;inset:0;background:
  radial-gradient(ellipse 70% 50% at 50% 110%,rgba(123,79,255,0.2) 0%,transparent 60%),
  radial-gradient(ellipse 50% 40% at 15% 25%,rgba(0,212,255,0.1) 0%,transparent 55%),
  radial-gradient(ellipse 40% 30% at 85% 15%,rgba(255,34,85,0.08) 0%,transparent 50%);}
.menu-grid{position:absolute;inset:0;
  background-image:linear-gradient(rgba(123,79,255,0.05) 1px,transparent 1px),
    linear-gradient(90deg,rgba(123,79,255,0.05) 1px,transparent 1px);
  background-size:50px 50px;
  mask-image:radial-gradient(ellipse at center,black 20%,transparent 75%);}
.menu-inner{position:relative;z-index:1;text-align:center;max-width:620px;padding:0 24px;}
.menu-eyebrow{font-family:'Space Mono',monospace;font-size:0.6rem;letter-spacing:5px;
  color:var(--c2);margin-bottom:10px;opacity:0.6;text-transform:uppercase;}
.menu-title{font-size:clamp(4.5rem,11vw,8rem);letter-spacing:6px;line-height:0.88;color:#fff;
  font-weight:900;text-shadow:0 0 80px rgba(123,79,255,0.6),0 0 30px rgba(0,212,255,0.3),
  3px 3px 0 rgba(123,79,255,0.4);margin-bottom:6px;}
.menu-title .accent{color:var(--c1);}
.menu-sub{font-family:'Space Mono',monospace;font-size:0.68rem;color:#3a3a5a;
  letter-spacing:4px;margin-bottom:32px;}
.menu-controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:28px;}
.ctrl-card{background:rgba(123,79,255,0.05);border:1px solid rgba(123,79,255,0.18);
  border-radius:6px;padding:14px;text-align:left;}
.ctrl-card-label{font-family:'Space Mono',monospace;font-size:0.58rem;letter-spacing:3px;
  color:var(--c2);margin-bottom:7px;text-transform:uppercase;}
.ctrl-card-keys{font-family:'Space Mono',monospace;font-size:0.68rem;color:#666;line-height:1.9;}
.ctrl-card-keys b{background:rgba(0,212,255,0.1);border:1px solid rgba(0,212,255,0.3);
  border-radius:3px;padding:1px 5px;color:#bbb;font-size:0.65rem;}
.menu-btn-row{display:flex;gap:10px;justify-content:center;margin-bottom:12px;}
.play-btn{padding:14px 52px;background:linear-gradient(135deg,var(--c1),var(--c4));
  border:none;border-radius:5px;color:#fff;font-family:'Orbitron',sans-serif;
  font-size:1.15rem;font-weight:700;letter-spacing:5px;cursor:none;transition:all 0.25s;
  box-shadow:0 0 40px rgba(123,79,255,0.5),0 6px 20px rgba(0,0,0,0.4);text-transform:uppercase;}
.play-btn:hover{transform:translateY(-2px);box-shadow:0 0 60px rgba(123,79,255,0.8);}
.levels-btn{padding:14px 28px;background:transparent;border:1px solid rgba(0,212,255,0.35);
  border-radius:5px;color:var(--c2);font-family:'Orbitron',sans-serif;font-size:0.95rem;
  font-weight:700;letter-spacing:4px;cursor:none;transition:all 0.25s;}
.levels-btn:hover{background:rgba(0,212,255,0.07);border-color:var(--c2);}
.menu-tagline{font-family:'Space Mono',monospace;font-size:0.58rem;color:#2a2a3a;letter-spacing:2px;}

/* LEVELS SCREEN */
#levelsScreen{position:fixed;inset:0;z-index:205;display:none;align-items:center;
  justify-content:center;background:var(--dark);}
#levelsScreen.show{display:flex;}
.levels-bg{position:absolute;inset:0;background:
  radial-gradient(ellipse 60% 60% at 50% 50%,rgba(123,79,255,0.1) 0%,transparent 65%);}
.levels-inner{position:relative;z-index:1;text-align:center;max-width:680px;padding:0 24px;}
.levels-title{font-size:2.4rem;font-weight:900;letter-spacing:6px;color:#fff;
  margin-bottom:4px;text-shadow:0 0 30px rgba(123,79,255,0.5);}
.levels-sub{font-family:'Space Mono',monospace;font-size:0.58rem;color:#333;
  letter-spacing:3px;margin-bottom:28px;}
.levels-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:24px;}
.stage-card{background:rgba(123,79,255,0.05);border:1px solid rgba(123,79,255,0.18);
  border-radius:8px;padding:20px;text-align:left;cursor:none;transition:all 0.25s;
  position:relative;overflow:hidden;}
.stage-card.unlocked:hover{background:rgba(123,79,255,0.13);border-color:var(--c1);
  transform:translateY(-2px);box-shadow:0 8px 30px rgba(123,79,255,0.25);}
.stage-card.locked{opacity:0.35;filter:grayscale(0.5);cursor:default;}
.stage-card-num{font-family:'Space Mono',monospace;font-size:0.55rem;color:var(--c2);
  letter-spacing:3px;margin-bottom:8px;}
.stage-card-name{font-size:1rem;font-weight:700;letter-spacing:3px;color:#fff;margin-bottom:4px;}
.stage-card-range{font-family:'Space Mono',monospace;font-size:0.6rem;color:#444;
  letter-spacing:2px;margin-bottom:10px;}
.stage-card-action{font-family:'Space Mono',monospace;font-size:0.6rem;
  color:var(--c2);letter-spacing:2px;}
.stage-card.locked .stage-card-action{color:#333;}
.stage-card-lock{position:absolute;top:12px;right:14px;font-size:1.1rem;opacity:0.4;}
.stage-card-bar{position:absolute;bottom:0;left:0;height:2px;width:0%;
  background:linear-gradient(90deg,var(--c1),var(--c2));transition:width 0.35s;}
.stage-card.unlocked:hover .stage-card-bar{width:100%;}
.back-btn{font-family:'Space Mono',monospace;font-size:0.65rem;letter-spacing:3px;
  color:#333;background:none;border:none;cursor:none;transition:color 0.2s;padding:8px 16px;}
.back-btn:hover{color:var(--c2);}

/* PAUSE */
#pauseScreen{position:fixed;inset:0;z-index:190;background:rgba(3,2,10,0.95);
  backdrop-filter:blur(20px);display:none;align-items:center;justify-content:center;}
#pauseScreen.show{display:flex;}
.pause-content{text-align:center;}
.pause-title{font-size:3.5rem;font-weight:900;letter-spacing:8px;color:#fff;
  text-shadow:0 0 40px rgba(123,79,255,0.5);margin-bottom:10px;}
.pause-sub{font-family:'Space Mono',monospace;font-size:0.65rem;color:#333;
  letter-spacing:4px;margin-bottom:32px;}

/* DEATH */
#deathScreen{position:fixed;inset:0;z-index:201;display:none;align-items:center;
  justify-content:center;background:rgba(3,2,10,0.97);}
#deathScreen.show{display:flex;animation:dfade 0.5s ease;}
@keyframes dfade{from{opacity:0;transform:scale(1.02);}to{opacity:1;transform:scale(1);}}
.death-inner{text-align:center;max-width:480px;padding:0 20px;}
.death-title{font-size:clamp(2.8rem,7vw,4.2rem);font-weight:900;letter-spacing:6px;
  color:var(--c4);text-shadow:0 0 50px rgba(255,34,85,0.7);margin-bottom:6px;
  animation:dpulse 2s ease infinite;}
@keyframes dpulse{0%,100%{text-shadow:0 0 50px rgba(255,34,85,0.7);}
  50%{text-shadow:0 0 80px rgba(255,34,85,1),0 0 120px rgba(255,34,85,0.4);}}
.death-sub{font-family:'Space Mono',monospace;font-size:0.65rem;color:#2a2a3a;
  letter-spacing:3px;margin-bottom:28px;}
.death-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:28px;}
.death-stat{background:rgba(255,34,85,0.05);border:1px solid rgba(255,34,85,0.18);
  border-radius:6px;padding:12px;}
.death-stat-label{font-family:'Space Mono',monospace;font-size:0.55rem;color:#333;
  letter-spacing:3px;margin-bottom:5px;}
.death-stat-val{font-size:1.7rem;color:#fff;font-weight:700;}
.btn-row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
.btn-retry{padding:11px 32px;background:linear-gradient(135deg,var(--c4),var(--c3));
  border:none;border-radius:4px;color:#fff;font-family:'Orbitron',sans-serif;
  font-size:0.9rem;font-weight:700;letter-spacing:3px;cursor:none;transition:all 0.25s;
  box-shadow:0 0 25px rgba(255,34,85,0.3);}
.btn-retry:hover{transform:translateY(-2px);box-shadow:0 0 40px rgba(255,34,85,0.6);}
.btn-menu{padding:11px 20px;background:transparent;border:1px solid rgba(255,255,255,0.12);
  border-radius:4px;color:#555;font-family:'Orbitron',sans-serif;font-size:0.85rem;
  letter-spacing:3px;cursor:none;transition:all 0.25s;}
.btn-menu:hover{color:#fff;border-color:rgba(255,255,255,0.35);}

/* HUD */
#hud{position:fixed;top:0;left:0;right:0;z-index:100;padding:9px 14px;
  display:none;align-items:center;gap:7px;
  background:rgba(3,2,15,0.88);backdrop-filter:blur(18px);
  border-bottom:1px solid rgba(123,79,255,0.18);box-shadow:0 2px 24px rgba(0,0,0,0.7);}
#hud.show{display:flex;}
.hud-stat{background:rgba(123,79,255,0.06);border:1px solid rgba(123,79,255,0.15);
  border-radius:5px;padding:6px 12px;min-width:72px;}
.hud-label{font-family:'Space Mono',monospace;font-size:0.5rem;letter-spacing:3px;
  color:rgba(0,212,255,0.55);margin-bottom:1px;text-transform:uppercase;}
.hud-value{font-size:1.4rem;color:#fff;font-weight:700;line-height:1;letter-spacing:1px;}
.stamina-wrap{background:rgba(123,79,255,0.06);border:1px solid rgba(123,79,255,0.15);
  border-radius:5px;padding:6px 12px;flex:1;max-width:190px;}
.stamina-track{height:4px;background:rgba(255,255,255,0.07);border-radius:2px;overflow:hidden;margin-top:5px;}
.stamina-bar{height:100%;width:100%;background:linear-gradient(90deg,var(--c1),var(--c2));
  border-radius:2px;transition:width 0.1s;box-shadow:0 0 5px rgba(0,212,255,0.5);}
.stamina-bar.low{animation:sblink 0.4s ease infinite;}
@keyframes sblink{0%,100%{opacity:1;}50%{opacity:0.2;}}
.stage-badge{margin-left:auto;background:rgba(123,79,255,0.06);
  border:1px solid rgba(123,79,255,0.15);border-radius:5px;padding:6px 12px;text-align:right;}
.stage-name{font-size:0.78rem;letter-spacing:4px;color:var(--c1);font-weight:700;}
.stage-progress{font-family:'Space Mono',monospace;font-size:0.5rem;color:#333;
  letter-spacing:2px;margin-top:2px;}

/* LAUNCH GAUGE */
#launchGauge{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
  z-index:100;display:none;flex-direction:column;align-items:center;gap:5px;pointer-events:none;}
#launchGauge.show{display:flex;}
.launch-label{font-family:'Space Mono',monospace;font-size:0.6rem;letter-spacing:3px;
  color:var(--gold);text-shadow:0 0 8px var(--gold);}
.launch-track{width:150px;height:9px;background:rgba(255,255,255,0.07);border-radius:4px;
  overflow:hidden;border:1px solid rgba(255,208,0,0.25);}
.launch-fill{height:100%;width:0%;
  background:linear-gradient(90deg,#44FF99,#FFD000,#FF4444);
  border-radius:4px;transition:width 0.04s;box-shadow:0 0 8px rgba(255,208,0,0.5);}

/* GRAB HINTS */
#grabHints{position:fixed;bottom:70px;left:50%;transform:translateX(-50%);
  z-index:100;display:flex;gap:14px;pointer-events:none;}
.grab-chip{background:rgba(3,2,15,0.92);border:1px solid rgba(0,212,255,0.3);
  border-radius:16px;padding:5px 12px;font-family:'Space Mono',monospace;font-size:0.65rem;
  letter-spacing:3px;color:var(--gold);text-shadow:0 0 6px var(--gold);
  opacity:0;transform:translateY(6px);transition:opacity 0.2s,transform 0.2s;}
.grab-chip.show{opacity:1;transform:translateY(0);}

/* STRIP */
#strip{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);z-index:100;
  background:rgba(3,2,15,0.92);backdrop-filter:blur(16px);
  border:1px solid rgba(123,79,255,0.22);border-radius:40px;padding:7px 20px;
  display:none;align-items:center;gap:12px;font-family:'Space Mono',monospace;
  font-size:0.58rem;color:#444;letter-spacing:1px;box-shadow:0 -2px 20px rgba(0,0,0,0.6);}
#strip.show{display:flex;}
.sk{background:rgba(123,79,255,0.1);border:1px solid rgba(123,79,255,0.28);
  border-radius:3px;padding:1px 5px;color:#999;font-size:0.58rem;}

/* LOCK MSG */
#lockMsg{position:fixed;inset:0;z-index:189;background:rgba(3,2,10,0.92);
  backdrop-filter:blur(12px);display:none;align-items:center;justify-content:center;
  flex-direction:column;gap:10px;font-family:'Space Mono',monospace;
  font-size:0.75rem;color:#777;letter-spacing:3px;text-align:center;}
#lockMsg.show{display:flex;}

/* CAM MODE LABEL */
#camModeLabel{position:fixed;top:48%;left:50%;transform:translate(-50%,-50%);z-index:110;
  pointer-events:none;font-size:1.3rem;letter-spacing:6px;font-weight:700;
  color:#fff;text-shadow:0 0 20px rgba(0,212,255,0.8);opacity:0;transition:opacity 0.4s;}
</style>
</head>
<body>

<div id="cursor"></div>
<div id="vignette"></div>
<div id="scanlines"></div>
<div id="chroma"></div>
<div id="flash"></div>
<div id="cpFlash"></div>
<div id="cpMsg">CHECKPOINT</div>

<!-- MENU -->
<div id="menu">
  <div class="menu-bg"></div>
  <div class="menu-grid"></div>
  <div class="menu-inner">
    <div class="menu-eyebrow">STICKGAMES ¬∑ GALAXY EDITION</div>
    <div class="menu-title">STICK<br><span class="accent">CLIMB</span></div>
    <div class="menu-sub">Physics-Based Vertical Climbing</div>
    <div class="menu-controls-grid">
      <div class="ctrl-card">
        <div class="ctrl-card-label">üîµ Left Arm</div>
        <div class="ctrl-card-keys">Move: <b>W</b><b>A</b><b>S</b><b>D</b><br>Hook: <b>SHIFT</b></div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">üî¥ Right Arm</div>
        <div class="ctrl-card-keys">Move: <b>‚Üë</b><b>‚Üê</b><b>‚Üì</b><b>‚Üí</b><br>Hook: <b>ENTER</b></div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">üöÄ Launch</div>
        <div class="ctrl-card-keys">Both hooked, hold<br><b>S</b> + <b>‚Üì</b> then release</div>
      </div>
      <div class="ctrl-card">
        <div class="ctrl-card-label">üì∑ Camera</div>
        <div class="ctrl-card-keys">Look: <b>MOUSE</b><br>Toggle: <b>V</b></div>
      </div>
    </div>
    <div class="menu-btn-row">
      <button class="play-btn" onclick="startGame()">LAUNCH</button>
      <button class="levels-btn" onclick="showLevels()">STAGES</button>
    </div>
    <div class="menu-tagline">4 STAGES ¬∑ CHECKPOINTS ¬∑ GALAXY ASCENT ¬∑ MOMENTUM PHYSICS</div>
  </div>
</div>

<!-- LEVELS SCREEN -->
<div id="levelsScreen">
  <div class="levels-bg"></div>
  <div class="levels-inner">
    <div class="levels-title">STAGES</div>
    <div class="levels-sub">REACH A STAGE TO UNLOCK IT</div>
    <div class="levels-grid" id="levelsGrid"></div>
    <button class="back-btn" onclick="hideLevels()">‚Üê BACK TO MENU</button>
  </div>
</div>

<!-- PAUSE -->
<div id="pauseScreen">
  <div class="pause-content">
    <div class="pause-title">PAUSED</div>
    <div class="pause-sub">PRESS ESC TO RESUME</div>
    <button class="play-btn" onclick="resumeGame()">RESUME</button>
  </div>
</div>

<!-- DEATH -->
<div id="deathScreen">
  <div class="death-inner">
    <div class="death-title">YOU FELL</div>
    <div class="death-sub">THE VOID CLAIMS ANOTHER</div>
    <div class="death-grid">
      <div class="death-stat">
        <div class="death-stat-label">Max Height</div>
        <div class="death-stat-val" id="dHeight">0m</div>
      </div>
      <div class="death-stat">
        <div class="death-stat-label">Time</div>
        <div class="death-stat-val" id="dTime">0:00</div>
      </div>
      <div class="death-stat">
        <div class="death-stat-label">Grabs</div>
        <div class="death-stat-val" id="dGrabs">0</div>
      </div>
    </div>
    <div class="btn-row">
      <button class="btn-retry" onclick="restartGame()">RESTART</button>
      <button class="btn-retry" style="background:linear-gradient(135deg,#1a5c3a,#2a8855)" onclick="respawnAtCheckpoint()">‚Ü© CHECKPOINT</button>
      <button class="btn-menu" onclick="showMenu()">MENU</button>
    </div>
  </div>
</div>

<!-- LOCK MSG -->
<div id="lockMsg">
  <div>CLICK TO LOCK CURSOR</div>
  <div style="color:#333;font-size:0.6rem;letter-spacing:2px;margin-top:4px;">ESC TO PAUSE</div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-stat"><div class="hud-label">Height</div><div class="hud-value" id="hHeight">0m</div></div>
  <div class="hud-stat"><div class="hud-label">Time</div><div class="hud-value" id="hTime">0:00</div></div>
  <div class="hud-stat"><div class="hud-label">Grabs</div><div class="hud-value" id="hGrabs">0</div></div>
  <div class="stamina-wrap">
    <div class="hud-label">Stamina</div>
    <div class="stamina-track"><div class="stamina-bar" id="stBar" style="width:100%"></div></div>
  </div>
  <div class="stage-badge">
    <div class="stage-name" id="stageName">NEBULA BASE</div>
    <div class="stage-progress" id="stageProgress">STAGE 1 / 4</div>
  </div>
</div>

<!-- LAUNCH GAUGE -->
<div id="launchGauge">
  <div class="launch-label">CHARGING LAUNCH</div>
  <div class="launch-track"><div class="launch-fill" id="launchFill"></div></div>
</div>

<div id="grabHints">
  <div class="grab-chip" id="chipL">SHIFT TO HOOK</div>
  <div class="grab-chip" id="chipR">ENTER TO HOOK</div>
</div>

<div id="strip">
  <span>üîµ <span class="sk">WASD</span><span class="sk">SHIFT</span></span>
  <span style="color:#222">|</span>
  <span>üî¥ <span class="sk">ARROWS</span><span class="sk">ENTER</span></span>
  <span style="color:#222">|</span>
  <span>üöÄ <span class="sk">S+‚Üì</span></span>
  <span style="color:#222">|</span>
  <span><span class="sk">V</span>CAM <span class="sk">ESC</span>PAUSE</span>
</div>

<div id="camModeLabel">üé• THIRD PERSON</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STICK CLIMB ‚Äì GALAXY EDITION
// Physics-based vertical climbing ¬∑ Deep space
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const $ = id => document.getElementById(id);
const PI = Math.PI, TWO_PI = PI * 2;
const V3 = (x=0,y=0,z=0) => new THREE.Vector3(x,y,z);
const clamp = (v,mn,mx) => Math.max(mn, Math.min(mx,v));

// ‚îÄ‚îÄ‚îÄ AUDIO ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const AC = new (window.AudioContext || window.webkitAudioContext)();

function playSFX(freq, dur=0.1, type='square', vol=0.12, detune=0){
  try{
    const o = AC.createOscillator();
    const g = AC.createGain();
    const f = AC.createBiquadFilter();
    f.type='bandpass'; f.frequency.value=freq*2; f.Q.value=0.8;
    o.type=type; o.frequency.value=freq;
    if(detune) o.detune.value=detune;
    g.gain.value=vol;
    o.connect(f); f.connect(g); g.connect(AC.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+dur);
    setTimeout(()=>o.stop(), dur*1000+50);
  }catch(e){}
}

function playGrab(){ playSFX(300+Math.random()*120, 0.09, 'sawtooth', 0.18); }
function playFall(){ playSFX(80, 0.5, 'sawtooth', 0.2); playSFX(120, 0.3,'sine',0.12); }
function playCheckpoint(){ playSFX(880,0.15,'sine',0.2); setTimeout(()=>playSFX(1320,0.2,'sine',0.18),120); }
function playLow(){ playSFX(160+Math.random()*40,0.12,'sawtooth',0.1); }
function playSlip(){ playSFX(200,0.15,'sawtooth',0.15,-200); }

// ‚îÄ‚îÄ‚îÄ CURSOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const cursor = $('cursor');
document.addEventListener('mousemove', e => {
  cursor.style.left = e.clientX+'px';
  cursor.style.top = e.clientY+'px';
});

// ‚îÄ‚îÄ‚îÄ THREE SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let scene, camera, renderer;

function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x05030A, 0.008);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.05, 1200);
  camera.rotation.order = 'YXZ';

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
}

initThree();

// ‚îÄ‚îÄ‚îÄ MATERIALS CACHE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const MAT = {
  crowbarMetal: new THREE.MeshPhysicalMaterial({
    color:0x222222, metalness:0.95, roughness:0.15, reflectivity:0.8
  }),
  holdRing: new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide})
};

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let G = null;

// Stage definitions
const STAGES = [
  { name:'NEBULA BASE',     yMin:0,   yMax:260,  color:0x060215, fog:0x04010E, fogD:0.008, ambCol:0x7B4FFF, ambInt:0.5, sunCol:0x9966FF, sunInt:1.4, bgCol:0x04010C, nebCol:0x7B4FFF },
  { name:'STELLAR DRIFT',   yMin:260, yMax:520,  color:0x020A18, fog:0x010810, fogD:0.008, ambCol:0x00D4FF, ambInt:0.5, sunCol:0x0088FF, sunInt:1.6, bgCol:0x010610, nebCol:0x0055AA },
  { name:'PULSAR RIDGE',    yMin:520, yMax:780,  color:0x150520, fog:0x0D0318, fogD:0.007, ambCol:0xFF2288, ambInt:0.5, sunCol:0xFF44AA, sunInt:1.8, bgCol:0x0A0110, nebCol:0xFF2288 },
  { name:'DEEP VOID',       yMin:780, yMax:9999, color:0x000208, fog:0x000106, fogD:0.004, ambCol:0x4488FF, ambInt:0.3, sunCol:0x6699FF, sunInt:1.0, bgCol:0x000104, nebCol:0x224488 }
];

const HOLD_TYPES = ['sphere','pipe','slab','crystal'];

// ‚îÄ‚îÄ‚îÄ PROGRESS TRACKING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let unlockedStages = new Set([0]); // stage 0 always unlocked

function unlockStage(idx){
  if(!unlockedStages.has(idx)){
    unlockedStages.add(idx);
    try{ localStorage.setItem('sc_unlocked', JSON.stringify([...unlockedStages])); }catch(e){}
  }
}

// Load saved progress
try{
  const saved = JSON.parse(localStorage.getItem('sc_unlocked')||'[0]');
  saved.forEach(i=>unlockedStages.add(i));
}catch(e){}

function showLevels(){
  $('menu').classList.add('hide');
  $('levelsScreen').classList.add('show');
  renderLevelsGrid();
}

function hideLevels(){
  $('levelsScreen').classList.remove('show');
  $('menu').classList.remove('hide');
}

function renderLevelsGrid(){
  const grid = $('levelsGrid');
  const ranges = ['0 ‚Äì 260m','260 ‚Äì 520m','520 ‚Äì 780m','780m+'];
  let html = '';
  for(let i=0;i<STAGES.length;i++){
    const s = STAGES[i];
    const unlocked = unlockedStages.has(i);
    const cls = unlocked ? 'unlocked' : 'locked';
    const action = unlocked ? '<div class="stage-card-action">&#9654; PLAY</div>' : '';
    const lock = unlocked ? '' : '<div class="stage-card-lock">&#128274;</div>';
    const click = unlocked ? 'onclick="startFromStage('+i+')"' : '';
    html += '<div class="stage-card '+cls+'" data-stage="'+i+'" '+click+'>'
      + '<div class="stage-card-num">STAGE '+(i+1)+' / 4</div>'
      + '<div class="stage-card-name">'+s.name+'</div>'
      + '<div class="stage-card-range">'+ranges[i]+'</div>'
      + action + lock
      + '<div class="stage-card-bar"></div>'
      + '</div>';
  }
  grid.innerHTML = html;
}

function startFromStage(stageIdx){
  $('levelsScreen').classList.remove('show');
  startGame(stageIdx);
}
const ARM_LENGTH = 9.0;   // max arm extension
const GRAB_RADIUS = 11.0; // how close a hold must be to grab
const BODY_MASS  = 1.0;
const GRAVITY    = 0.22;
const DRAG       = 0.025;

// ‚îÄ‚îÄ‚îÄ STAGE VISUAL SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let ambientLight, sunLight, backLight, fillLight;

function setupLights(){
  ambientLight = new THREE.AmbientLight(0xFF6B00, 0.4);
  scene.add(ambientLight);

  sunLight = new THREE.DirectionalLight(0xFF6B00, 1.5);
  sunLight.position.set(20, 200, 30);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.set(2048,2048);
  sunLight.shadow.camera.left = -80;
  sunLight.shadow.camera.right = 80;
  sunLight.shadow.camera.top = 200;
  sunLight.shadow.camera.bottom = -30;
  sunLight.shadow.bias = -0.0003;
  scene.add(sunLight);

  backLight = new THREE.PointLight(0xFF2200, 1.2, 200);
  backLight.position.set(-20, 200, -40);
  scene.add(backLight);

  fillLight = new THREE.PointLight(0x6622FF, 0.6, 150);
  fillLight.position.set(30, 100, 20);
  scene.add(fillLight);
}

function updateStageLights(stageIdx){
  const s = STAGES[stageIdx];
  scene.fog.color.set(s.fog);
  scene.fog.density = s.fogD;
  renderer.setClearColor(s.bgCol);
  ambientLight.color.set(s.ambCol); ambientLight.intensity = s.ambInt;
  sunLight.color.set(s.sunCol); sunLight.intensity = s.sunInt;
}

// ‚îÄ‚îÄ‚îÄ GALAXY STARFIELD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildStarfield(){
  // Layer 1: tiny distant white stars
  {
    const geo = new THREE.BufferGeometry();
    const v = [];
    for(let i=0;i<18000;i++){
      v.push((Math.random()-0.5)*3000, Math.random()*1400-100, (Math.random()-0.5)*3000);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v,3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color:0xCCDDFF,size:0.9,transparent:true,opacity:0.7,sizeAttenuation:true})));
  }
  // Layer 2: medium blue-tinted stars
  {
    const geo = new THREE.BufferGeometry();
    const v = [];
    for(let i=0;i<5000;i++){
      v.push((Math.random()-0.5)*2000, Math.random()*1200-50, (Math.random()-0.5)*2000);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v,3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color:0x88AAFF,size:2.2,transparent:true,opacity:0.6,sizeAttenuation:true})));
  }
  // Layer 3: large colored hero stars (purple / cyan / pink)
  {
    const geo = new THREE.BufferGeometry();
    const v = [], c = [];
    const heroColors = [[0.5,0.3,1],[0,0.8,1],[1,0.15,0.5],[0.7,0.5,1],[0,1,0.9]];
    for(let i=0;i<800;i++){
      v.push((Math.random()-0.5)*1800, Math.random()*1100, (Math.random()-0.5)*1800);
      const col = heroColors[Math.floor(Math.random()*heroColors.length)];
      c.push(...col);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v,3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(c,3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({vertexColors:true,size:3.5,transparent:true,opacity:0.9,sizeAttenuation:true})));
  }
  // Nebula cloud planes (canvas texture billboards)
  buildNebulaClouds();
}

function makeNebulaCanvas(r,g,b){
  const c = document.createElement('canvas');
  c.width=256; c.height=256;
  const ctx = c.getContext('2d');
  const grd = ctx.createRadialGradient(128,128,0,128,128,128);
  grd.addColorStop(0, 'rgba('+r+','+g+','+b+',0.55)');
  grd.addColorStop(0.35, 'rgba('+r+','+g+','+b+',0.2)');
  grd.addColorStop(0.7, 'rgba('+r+','+g+','+b+',0.06)');
  grd.addColorStop(1, 'rgba('+r+','+g+','+b+',0)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,256,256);
  for(let i=0;i<8;i++){
    const bx=60+Math.random()*136, by=60+Math.random()*136, br=20+Math.random()*40;
    const bg = ctx.createRadialGradient(bx,by,0,bx,by,br);
    bg.addColorStop(0, 'rgba('+r+','+g+','+b+',0.15)');
    bg.addColorStop(1, 'transparent');
    ctx.fillStyle = bg; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
  }
  return new THREE.CanvasTexture(c);
}

function buildNebulaClouds(){
  const nebDefs = [
    {r:123,g:79,b:255,  y:80,  x:-40, s:180},
    {r:0,  g:180,b:255, y:320, x:50,  s:200},
    {r:255,g:30, b:120, y:570, x:-60, s:160},
    {r:70, g:120,b:255, y:820, x:30,  s:220},
    {r:180,g:60, b:255, y:200, x:70,  s:140},
    {r:0,  g:220,b:200, y:440, x:-80, s:170},
  ];
  for(const d of nebDefs){
    const tex = makeNebulaCanvas(d.r,d.g,d.b);
    const mat = new THREE.MeshBasicMaterial({map:tex,transparent:true,opacity:0.55,
      side:THREE.DoubleSide,depthWrite:false});
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(d.s,d.s), mat);
    mesh.position.set(d.x, d.y, -60-Math.random()*40);
    mesh.rotation.z = Math.random()*Math.PI;
    scene.add(mesh);
  }
}

// ‚îÄ‚îÄ‚îÄ MAIN WALL GEOMETRY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildWall(){
  // Background wall spans full height
  for(let y=0;y<200;y++){
    const geo = new THREE.BoxGeometry(60, 6.5, 2.5);
    const stageIdx = Math.floor(y / 40);
    const si = Math.min(stageIdx, STAGES.length-1);
    const mat = new THREE.MeshPhongMaterial({
      color: STAGES[si].color,
      emissive: STAGES[si].color,
      emissiveIntensity: 0.12,
      flatShading: true
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, y*6.5, -10);
    mesh.receiveShadow = true;
    scene.add(mesh);
  }

  // Vertical support columns
  for(let x = -4; x <= 4; x++){
    const geo = new THREE.CylinderGeometry(0.5, 0.5, 1300, 12);
    const mat = new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111, shininess:80});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x*7, 650, -10.5);
    mesh.castShadow = true;
    scene.add(mesh);
  }

  // Stage divider beams
  for(const s of STAGES.slice(1)){
    const geo = new THREE.BoxGeometry(62, 1.5, 3);
    const mat = new THREE.MeshPhongMaterial({
      color:0x111111, emissive:0x220022, emissiveIntensity:0.5
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, s.yMin, -10);
    scene.add(mesh);

    // Glowing stage marker
    const gGeo = new THREE.BoxGeometry(62,0.3,0.3);
    const gMat = new THREE.MeshBasicMaterial({color:0xFF6B00});
    const gMesh = new THREE.Mesh(gGeo, gMat);
    gMesh.position.set(0, s.yMin+0.8, -8.5);
    scene.add(gMesh);
  }

  // Starting platform
  const pGeo = new THREE.BoxGeometry(24, 1.5, 8);
  const pMat = new THREE.MeshPhongMaterial({color:0x1a0a00, emissive:0x110800, shininess:20});
  const platform = new THREE.Mesh(pGeo, pMat);
  platform.position.set(0, -1, -5);
  platform.receiveShadow = true;
  platform.castShadow = true;
  scene.add(platform);

  // Platform glow edges
  const egGeo = new THREE.BoxGeometry(24, 0.2, 0.2);
  const egMat = new THREE.MeshBasicMaterial({color:0xFF6B00});
  const eg = new THREE.Mesh(egGeo, egMat);
  eg.position.set(0, -0.2, -1);
  scene.add(eg);
}

// ‚îÄ‚îÄ‚îÄ HOLD CREATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function holdColor(stageIdx){
  const palettes = [
    [0xFF6B00, 0xFF9000, 0xFF4400, 0xFFCC00, 0xCC4400],
    [0xFF2200, 0xFF6600, 0xFF0000, 0xFF4422, 0xCC2200],
    [0x9B4DFF, 0x00FFE5, 0xFF00AA, 0x4499FF, 0xDD44FF],
    [0x4466FF, 0x8888FF, 0x44CCFF, 0xFFFFFF, 0x6688FF]
  ];
  const p = palettes[stageIdx] || palettes[0];
  return p[Math.floor(Math.random()*p.length)];
}

function createHold(x, y, z, type, stageIdx, moving=false){
  const group = new THREE.Group();
  const col = holdColor(stageIdx);
  const emMat = new THREE.MeshPhongMaterial({
    color:col, emissive:col, emissiveIntensity:0.6, shininess:100
  });

  let mainMesh;
  if(type==='sphere'){
    const geo = new THREE.SphereGeometry(0.85, 20, 20);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    // Eyes
    const eMat = new THREE.MeshBasicMaterial({color:0xffffff});
    const pupMat = new THREE.MeshBasicMaterial({color:0x000000});
    for(let side of [-1,1]){
      const e = new THREE.Mesh(new THREE.SphereGeometry(0.18,12,12), eMat);
      e.position.set(side*0.28, 0.1, 0.78);
      const p = new THREE.Mesh(new THREE.SphereGeometry(0.09,8,8), pupMat);
      p.position.set(side*0.28, 0.1, 0.89);
      group.add(e, p);
    }
  } else if(type==='pipe'){
    const geo = new THREE.CylinderGeometry(0.3, 0.3, 3.5, 16);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    mainMesh.rotation.z = PI/2;
    // End caps
    for(let s of [-1,1]){
      const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.2,16), emMat.clone());
      cap.rotation.z = PI/2;
      cap.position.x = s * 1.85;
      group.add(cap);
    }
  } else if(type==='slab'){
    const geo = new THREE.BoxGeometry(3.2, 0.55, 0.7);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    // Side brackets
    for(let s of [-1,1]){
      const bk = new THREE.Mesh(
        new THREE.BoxGeometry(0.25,0.8,0.8),
        new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111})
      );
      bk.position.x = s*1.7;
      group.add(bk);
    }
  } else { // crystal
    const geo = new THREE.OctahedronGeometry(0.9, 0);
    mainMesh = new THREE.Mesh(geo, emMat.clone());
    mainMesh.rotation.x = Math.random()*PI;
    mainMesh.rotation.z = Math.random()*PI;
  }

  mainMesh.castShadow = true;
  group.add(mainMesh);

  // Glow ring (shown when grabbable)
  const ringGeo = new THREE.TorusGeometry(1.4, 0.08, 16, 40);
  const ringMat = new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide});
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = PI/2;
  group.add(ring);

  group.position.set(x, y, z);
  group.userData = {
    type, col, grabbed:false, mainMesh, ring,
    moving, moveBase:new THREE.Vector3(x,y,z),
    moveAxis: moving?(['x','y'][Math.floor(Math.random()*2)]):'',
    moveAmp: 2+Math.random()*5,
    moveFreq: 0.3+Math.random()*0.7,
    movePhase: Math.random()*TWO_PI,
    stageIdx
  };

  scene.add(group);
  return group;
}

// ‚îÄ‚îÄ‚îÄ CHECKPOINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createCheckpoint(y){
  const group = new THREE.Group();

  // Ring
  const ringGeo = new THREE.TorusGeometry(5, 0.25, 16, 60);
  const mat = new THREE.MeshBasicMaterial({color:0x00FFE5});
  const ring = new THREE.Mesh(ringGeo, mat);
  ring.rotation.x = PI/2;
  group.add(ring);

  // Inner glow ring
  const innerGeo = new THREE.TorusGeometry(4.6, 0.08, 16, 60);
  const innerMat = new THREE.MeshBasicMaterial({color:0x00FFE5, transparent:true, opacity:0.4});
  group.add(new THREE.Mesh(innerGeo, innerMat));

  // Flag poles
  for(let s of [-1,1]){
    const pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.12, 10, 8),
      new THREE.MeshPhongMaterial({color:0x666666})
    );
    pole.position.set(s*5.5, -5, 0);
    group.add(pole);

    const flag = new THREE.Mesh(
      new THREE.PlaneGeometry(1.8, 1.1),
      new THREE.MeshBasicMaterial({color:0x00FFE5, side:THREE.DoubleSide})
    );
    flag.position.set(s*5.5 + s*0.9, -0.5, 0);
    group.add(flag);
  }

  group.position.set(0, y, -3);
  group.userData = { triggered:false };
  scene.add(group);
  return group;
}

// ‚îÄ‚îÄ‚îÄ MOVING OBSTACLE (GEAR) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createGear(x, y, z, stageIdx){
  const group = new THREE.Group();
  const col = holdColor(stageIdx);

  // Outer ring
  const rGeo = new THREE.TorusGeometry(3.5, 0.35, 16, 60);
  const mat = new THREE.MeshPhongMaterial({color:0x333333, emissive:0x111111, shininess:80});
  const outer = new THREE.Mesh(rGeo, mat);
  group.add(outer);

  // Teeth (boxes around perimeter)
  const toothMat = new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:0.4});
  const TEETH = 12;
  for(let i=0;i<TEETH;i++){
    const a = (i/TEETH)*TWO_PI;
    const tooth = new THREE.Mesh(
      new THREE.BoxGeometry(0.8, 0.9, 0.6),
      toothMat
    );
    tooth.position.set(Math.cos(a)*3.7, Math.sin(a)*3.7, 0);
    tooth.rotation.z = a;
    group.add(tooth);
  }

  // Spokes
  for(let i=0;i<6;i++){
    const a = (i/6)*TWO_PI;
    const spoke = new THREE.Mesh(
      new THREE.BoxGeometry(7, 0.3, 0.3),
      new THREE.MeshPhongMaterial({color:0x555555})
    );
    spoke.rotation.z = a;
    group.add(spoke);
  }

  // Center bolt
  const bolt = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16),
    new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:0.8})
  );
  bolt.rotation.x = PI/2;
  group.add(bolt);

  group.position.set(x, y, z);
  group.userData = { type:'gear', rotSpeed: 0.008+Math.random()*0.012, dir:Math.random()<0.5?1:-1 };
  scene.add(group);
  return group;
}

// ‚îÄ‚îÄ‚îÄ PARTICLE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const particles = [];

function spawnParticles(pos, col, count=8, speed=0.15){
  for(let i=0;i<count;i++){
    const geo = new THREE.SphereGeometry(0.1, 4, 4);
    const mat = new THREE.MeshBasicMaterial({color:col, transparent:true, opacity:1});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    particles.push({
      mesh, life:1.0,
      vel: V3((Math.random()-0.5)*speed*2, Math.random()*speed+0.05, (Math.random()-0.5)*speed)
    });
  }
}

function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= 0.04;
    p.vel.y -= 0.008;
    p.mesh.position.add(p.vel);
    p.mesh.material.opacity = p.life;
    p.mesh.scale.setScalar(p.life*0.8+0.2);
    if(p.life<=0){
      scene.remove(p.mesh);
      particles.splice(i,1);
    }
  }
}

// ‚îÄ‚îÄ‚îÄ HAND / CROWBAR OBJECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createHandObject(col, label){
  const group = new THREE.Group();

  // BIG bold cartoon blob body ‚Äî matches the reference (large flat sphere)
  const bodyMat = new THREE.MeshPhongMaterial({
    color:col, emissive:col, emissiveIntensity:0.45, shininess:30
  });
  const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), bodyMat);
  body.castShadow = true;
  group.add(body);

  // Flat white dot eyes (CircleGeometry facing forward ‚Äî clean 2D look)
  const whiteMat = new THREE.MeshBasicMaterial({color:0xFFFFFF, side:THREE.FrontSide});
  const pupilMat = new THREE.MeshBasicMaterial({color:0x111111, side:THREE.FrontSide});
  for(let s of [-1,1]){
    // white sclera
    const white = new THREE.Mesh(new THREE.CircleGeometry(0.32, 24), whiteMat);
    white.position.set(s*0.5, 0.2, 1.44);
    group.add(white);
    // dark pupil
    const pupil = new THREE.Mesh(new THREE.CircleGeometry(0.16, 16), pupilMat);
    pupil.position.set(s*0.5, 0.2, 1.46);
    group.add(pupil);
  }

  // Crowbar ‚Äî thin dark metal shaft
  const shaftMat = new THREE.MeshPhongMaterial({color:0x2a2a2a, emissive:0x111111, shininess:100});
  const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5.5, 12), shaftMat);
  shaft.position.set(0, 4.25, 0);
  shaft.castShadow = true;
  group.add(shaft);

  // Hook curve
  const hook = new THREE.Mesh(
    new THREE.TorusGeometry(0.4, 0.09, 10, 24, PI*1.15),
    shaftMat
  );
  hook.position.set(0, 7.0, 0);
  hook.rotation.x = PI/2;
  group.add(hook);

  // Spike tip
  const tip = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.4, 8), shaftMat);
  tip.position.set(0.4, 7.35, 0);
  tip.rotation.z = -PI/2;
  group.add(tip);

  // Grab glow ring ‚Äî visible when latched on
  const glowMat = new THREE.MeshBasicMaterial({color:0xFFD000, transparent:true, opacity:0, side:THREE.DoubleSide});
  const glow = new THREE.Mesh(new THREE.TorusGeometry(1.9, 0.08, 12, 40), glowMat);
  glow.rotation.x = PI/2;
  group.add(glow);

  group.userData = { glow, bodyMat, label };
  scene.add(group);

  return {
    group,
    pos: V3(),
    vel: V3(),
    hooked: false,
    hookHold: null,
    nearHold: null,
    swingMom: V3()
  };
}

// ‚îÄ‚îÄ‚îÄ PLAYER BODY OBJECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createPlayerBody(){
  const group = new THREE.Group();

  // Torso
  const torsoGeo = new THREE.CylinderGeometry(0.55, 0.55, 1.2, 16);
  const torsoMat = new THREE.MeshPhongMaterial({color:0x222244, emissive:0x111122, shininess:60});
  const torso = new THREE.Mesh(torsoGeo, torsoMat);
  torso.castShadow = true;
  group.add(torso);

  // Head
  const headGeo = new THREE.SphereGeometry(0.52, 20, 20);
  const headMat = new THREE.MeshPhongMaterial({color:0xFFCC99, emissive:0x221100, shininess:80});
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.set(0, 1.3, 0);
  head.castShadow = true;
  group.add(head);

  // Eyes
  const eMat = new THREE.MeshBasicMaterial({color:0x111111});
  for(let s of [-1,1]){
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), eMat);
    eye.position.set(s*0.2, 1.38, 0.46);
    group.add(eye);
  }

  // Hard hat
  const hatBrimGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.1, 16);
  const hatTopGeo  = new THREE.SphereGeometry(0.5, 16, 8, 0, TWO_PI, 0, PI/2);
  const hatMat = new THREE.MeshPhongMaterial({color:0xFFCC00, emissive:0x664400, emissiveIntensity:0.3});
  const hatBrim = new THREE.Mesh(hatBrimGeo, hatMat);
  hatBrim.position.set(0, 1.72, 0);
  const hatTop = new THREE.Mesh(hatTopGeo, hatMat);
  hatTop.position.set(0, 1.73, 0);
  group.add(hatBrim, hatTop);

  // Legs (2 cylinders)
  for(let s of [-1,1]){
    const leg = new THREE.Mesh(
      new THREE.CylinderGeometry(0.2, 0.18, 1.0, 10),
      new THREE.MeshPhongMaterial({color:0x1a1a3a})
    );
    leg.position.set(s*0.25, -1.1, 0);
    group.add(leg);

    // Boots
    const boot = new THREE.Mesh(
      new THREE.BoxGeometry(0.32, 0.22, 0.55),
      new THREE.MeshPhongMaterial({color:0x553300})
    );
    boot.position.set(s*0.25, -1.67, 0.1);
    group.add(boot);
  }

  scene.add(group);
  return group;
}

// ‚îÄ‚îÄ‚îÄ ARM ROPE LINES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createArmLines(){
  const mat = new THREE.LineBasicMaterial({
    color:0x888888, transparent:true, opacity:0.7, linewidth:1
  });

  function makeLine(){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0,0,0,0], 3));
    const line = new THREE.Line(geo, mat.clone());
    scene.add(line);
    return line;
  }

  return { left: makeLine(), right: makeLine() };
}

function updateArmLine(line, fromPos, toPos){
  const pos = line.geometry.attributes.position;
  pos.setXYZ(0, fromPos.x, fromPos.y, fromPos.z);
  pos.setXYZ(1, toPos.x, toPos.y, toPos.z);
  pos.needsUpdate = true;
}

// ‚îÄ‚îÄ‚îÄ GAME START ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startGame(stageIdx=0){
  $('menu').classList.add('hide');
  $('levelsScreen').classList.remove('show');
  $('hud').classList.add('show');
  $('strip').classList.add('show');

  // Resume AudioContext if needed
  if(AC.state==='suspended') AC.resume();

  // Clear old scene objects
  if(G){
    scene.children.slice().forEach(c=>{
      if(c.type!=='Points') scene.remove(c);
    });
  }

  setupLights();
  buildStarfield(); // galaxy multi-layer
  buildWall();

  G = {
    phase:'playing',
    camYaw: 0,
    camPitch: -0.1,
    camDist: 14,
    camTargetY: 10,
    camMode: 'third', // 'third' or 'first'
    fpYaw: 0,         // first-person yaw
    fpPitch: 0.6,     // first-person pitch (looking up by default)
    mouseX: 0,
    mouseY: 0,
    keys: {},

    body: {
      pos: V3(0, STAGES[stageIdx].yMin + 8, 2),
      vel: V3(),
      onGround: false
    },

    left:  null,
    right: null,

    holds: [],
    gears: [],
    checkpoints: [],
    checkpointIdx: 0,
    respawnPos: V3(0, STAGES[stageIdx].yMin + 8, 2),
    startStageIdx: stageIdx,

    stamina: 100,
    grabs: 0,
    maxHeight: 0,
    startTime: Date.now(),

    screenShake: 0,
    launchCharge: 0,
    launchCharging: false,
    stageIdx: 0,
    dead: false,
    paused: false
  };

  // Create hands
  G.left  = createHandObject(0x4488FF, 'L');
  G.right = createHandObject(0xFF3366, 'R');
  G.playerBody = createPlayerBody();
  G.armLines = createArmLines();

  // Ambient rain/lava particles
  G.envParticles = [];

  const startY = STAGES[stageIdx].yMin + 10;
  G.left.pos.set(-2.5, startY, 2);
  G.right.pos.set(2.5, startY, 2);
  G.left.group.position.copy(G.left.pos);
  G.right.group.position.copy(G.right.pos);
  G.camTargetY = startY;
  updateStageLights(stageIdx);

  // ‚îÄ Generate holds procedurally ‚îÄ
  generateHolds();

  // ‚îÄ Request pointer lock ‚îÄ
  renderer.domElement.requestPointerLock();

  updateStageLights(0);
  renderer.setClearColor(0x08040A);

  requestAnimationFrame(gameLoop);
}

function generateHolds(){
  // Create holds in clusters along a climbable path
  // Each "band" at certain height has a cluster of 3-5 holds within reach
  const TOTAL_HEIGHT = 900;
  const BAND_HEIGHT = 7;   // tighter vertical bands = more holds in reach
  const numBands = Math.floor(TOTAL_HEIGHT / BAND_HEIGHT);

  let prevClusterX = 0;

  for(let b=0; b<numBands; b++){
    const baseY = 15 + b * BAND_HEIGHT;
    const stageIdx = Math.min(STAGES.findIndex(s=>baseY>=s.yMin && baseY<s.yMax), STAGES.length-1);
    const safeStage = stageIdx < 0 ? STAGES.length-1 : stageIdx;

    const numHolds = 3 + Math.floor(Math.random()*3); // more holds per band
    // Cluster drifts gently so there's always something reachable
    const clusterX = clamp(prevClusterX + (Math.random()-0.5)*8, -14, 14);
    prevClusterX = clusterX;

    for(let h=0; h<numHolds; h++){
      const x = clusterX + (Math.random()-0.5)*10; // tighter X spread
      const y = baseY + (Math.random()-0.3)*BAND_HEIGHT*0.9;
      const z = -7 + Math.random()*2;  // closer to camera/player
      const type = HOLD_TYPES[Math.floor(Math.random()*HOLD_TYPES.length)];

      const movingChance = safeStage * 0.12;
      const moving = Math.random() < movingChance;

      const hold = createHold(x, y, z, type, safeStage, moving);
      G.holds.push(hold);
    }

    // Add gear obstacles every 50m from stage 2+
    if(b>0 && b%8===0 && safeStage>=1){
      const gx = (Math.random()-0.5)*30;
      const g = createGear(gx, baseY-3, -8, safeStage);
      G.gears.push(g);
    }
  }

  // Checkpoints every 130 units
  for(let y=120; y<TOTAL_HEIGHT; y+=130){
    const cp = createCheckpoint(y);
    G.checkpoints.push(cp);
  }
}

// ‚îÄ‚îÄ‚îÄ POINTER LOCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('pointerlockchange', ()=>{
  if(document.pointerLockElement === renderer.domElement){
    $('lockMsg').classList.remove('show');
    if(G && G.paused) resumeGame();
  } else if(G && !G.dead && !G.paused && G.phase==='playing'){
    G.paused = true;
    $('pauseScreen').classList.add('show');
  }
});

renderer.domElement.addEventListener('click', ()=>{
  if(G && !G.dead && !document.pointerLockElement){
    renderer.domElement.requestPointerLock();
  }
});

document.addEventListener('mousemove', e=>{
  if(!G || G.paused || G.dead) return;
  if(document.pointerLockElement === renderer.domElement){
    G.mouseX += e.movementX || 0;
    G.mouseY += e.movementY || 0;
  }
});

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('keydown', e=>{
  if(!G) return;
  G.keys[e.key] = true;
  G.keys[e.code] = true;

  if(e.key === 'Shift'){
    e.preventDefault();
    tryGrab(G.left);
  }
  if(e.key === 'Enter'){
    e.preventDefault();
    tryGrab(G.right);
  }
  if(e.key === 'Escape'){
    if(!G.dead){
      G.paused ? resumeGame() : pauseGame();
    }
  }
  if((e.key === 'v' || e.key === 'V') && G.phase==='playing'){
    G.camMode = G.camMode==='third' ? 'first' : 'third';
    $('camModeLabel').textContent = G.camMode==='first' ? 'üëÅ FIRST PERSON' : 'üé• THIRD PERSON';
    $('camModeLabel').style.opacity = '1';
    clearTimeout(G._camLabelTimer);
    G._camLabelTimer = setTimeout(()=>{ $('camModeLabel').style.opacity='0'; }, 2000);
  }
});

document.addEventListener('keyup', e=>{
  if(!G) return;
  G.keys[e.key] = false;
  G.keys[e.code] = false;

  if(e.key === 'Shift') releaseGrab(G.left);
  if(e.key === 'Enter') releaseGrab(G.right);
});

function pauseGame(){
  G.paused = true;
  document.exitPointerLock();
  $('pauseScreen').classList.add('show');
}

function resumeGame(){
  G.paused = false;
  $('pauseScreen').classList.remove('show');
  renderer.domElement.requestPointerLock();
}

// ‚îÄ‚îÄ‚îÄ GRAB LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function tryGrab(hand){
  if(hand.hooked || G.stamina < 4) return;

  // Find closest ungrabbed hold
  let best = null, bestDist = GRAB_RADIUS;
  for(const h of G.holds){
    if(h.userData.grabbed) continue;
    const d = hand.pos.distanceTo(h.position);
    if(d < bestDist){ best=h; bestDist=d; }
  }

  if(best){
    hand.hooked = true;
    hand.hookHold = best;
    best.userData.grabbed = true;
    best.userData.ring.material.opacity = 1.0;
    hand.group.userData.glow.material.opacity = 0.9;

    // Transfer momentum
    const dir = V3().subVectors(best.position, hand.pos).normalize();
    hand.swingMom.copy(dir).multiplyScalar(2.5);

    G.grabs++;
    playGrab();
    spawnParticles(hand.pos, best.userData.col, 10, 0.18);
    $('flash').style.opacity=0.25;
    setTimeout(()=>$('flash').style.opacity=0, 100);
  } else {
    playSlip();
  }
}

function releaseGrab(hand){
  if(!hand.hooked) return;
  if(hand.hookHold){
    hand.hookHold.userData.grabbed = false;
    hand.hookHold.userData.ring.material.opacity = 0;
    hand.hookHold = null;
  }
  hand.hooked = false;
  hand.group.userData.glow.material.opacity = 0;
}

// ‚îÄ‚îÄ‚îÄ PHYSICS UPDATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updatePhysics(dt){
  const stageIdx = G.stageIdx;
  const lowGrav = stageIdx >= 3; // void ascent
  const grav = lowGrav ? GRAVITY * 0.35 : GRAVITY;

  const lGrabbed = G.left.hooked;
  const rGrabbed = G.right.hooked;

  // ‚îÄ Body gravity ‚îÄ
  if(!lGrabbed && !rGrabbed){
    G.body.vel.y -= grav;
  } else if(lGrabbed && rGrabbed){
    G.body.vel.y *= 0.88;
    G.body.vel.x *= 0.92;
    G.body.vel.z *= 0.92;
  } else {
    G.body.vel.y -= grav * 0.3;
  }

  G.body.vel.multiplyScalar(1-DRAG);
  G.body.pos.add(G.body.vel);

  // ‚îÄ Body constraints from hands ‚îÄ
  for(const hand of [G.left, G.right]){
    if(!hand.hooked) continue;
    const hPos = hand.hookHold.position;
    const toBody = V3().subVectors(G.body.pos, hPos);
    const dist = toBody.length();
    if(dist > ARM_LENGTH){
      const normal = toBody.normalize();
      G.body.pos.copy(hPos).addScaledVector(normal, ARM_LENGTH);
      const vdot = G.body.vel.dot(normal);
      if(vdot > 0) G.body.vel.addScaledVector(normal, -vdot * 1.1);
    }
  }

  // ‚îÄ Ground constraint ‚îÄ
  if(G.body.pos.y < 0){
    G.body.pos.y = 0;
    if(G.body.vel.y < -8){
      G.screenShake = Math.min(1.5, -G.body.vel.y * 0.05);
      playLow();
    }
    G.body.vel.y = Math.max(0, G.body.vel.y);
    G.body.vel.x *= 0.8;
    G.body.vel.z *= 0.8;
    G.body.onGround = true;
  } else {
    G.body.onGround = false;
  }

  // ‚îÄ Update hand positions ‚îÄ
  updateHand(G.left,  'w','s','a','d', lGrabbed, rGrabbed, grav);
  updateHand(G.right, 'ArrowUp','ArrowDown','ArrowLeft','ArrowRight', rGrabbed, lGrabbed, grav);

  // ‚îÄ Stamina ‚îÄ
  const drainingStam = lGrabbed || rGrabbed;
  if(drainingStam){
    const drain = (lGrabbed && rGrabbed) ? 0.06 : 0.11;
    G.stamina = Math.max(0, G.stamina - drain);
    if(G.stamina === 0){
      if(lGrabbed){ releaseGrab(G.left); playSlip(); }
      if(rGrabbed){ releaseGrab(G.right); playSlip(); }
    }
  } else {
    G.stamina = Math.min(100, G.stamina + 0.18);
  }

  // ‚îÄ Platform respawn: if fell far below respawn point, teleport back ‚îÄ
  if(G.body.pos.y < G.respawnPos.y - 35){
    // Soft respawn - flash and teleport back to last checkpoint/platform
    G.body.pos.copy(G.respawnPos);
    G.body.vel.set(0,0,0);
    G.left.vel.set(0,0,0); G.right.vel.set(0,0,0);
    releaseGrab(G.left); releaseGrab(G.right);
    G.stamina = Math.max(G.stamina, 30);
    G.screenShake = 1.0;
    $('flash').style.opacity=0.4;
    setTimeout(()=>$('flash').style.opacity=0, 200);
    playSFX(120, 0.3, 'sawtooth', 0.18);
    return;
  }

  // ‚îÄ Max height ‚îÄ
  G.maxHeight = Math.max(G.maxHeight, Math.floor(G.body.pos.y));

  // ‚îÄ Moving holds ‚îÄ
  const t = Date.now() * 0.001;
  for(const h of G.holds){
    if(!h.userData.moving) continue;
    const ud = h.userData;
    const offset = Math.sin(t * ud.moveFreq + ud.movePhase) * ud.moveAmp;
    if(ud.moveAxis==='x') h.position.x = ud.moveBase.x + offset;
    else h.position.y = ud.moveBase.y + offset;
    // If hand is hooked to this hold, update hooked position
    for(const hand of [G.left, G.right]){
      if(hand.hooked && hand.hookHold===h){
        // body will be reconstrained next frame
      }
    }
  }

  // ‚îÄ Rotate gears ‚îÄ
  for(const g of G.gears){
    g.rotation.z += g.userData.rotSpeed * g.userData.dir;
  }

  // ‚îÄ Update arm lines ‚îÄ
  if(G.left.hooked && G.left.hookHold){
    updateArmLine(G.armLines.left, G.body.pos, G.left.hookHold.position);
    G.armLines.left.material.opacity = 0.8;
  } else {
    updateArmLine(G.armLines.left, G.body.pos, G.left.pos);
    G.armLines.left.material.opacity = 0.35;
  }
  if(G.right.hooked && G.right.hookHold){
    updateArmLine(G.armLines.right, G.body.pos, G.right.hookHold.position);
    G.armLines.right.material.opacity = 0.8;
  } else {
    updateArmLine(G.armLines.right, G.body.pos, G.right.pos);
    G.armLines.right.material.opacity = 0.35;
  }

  // ‚îÄ Update player body mesh ‚îÄ
  G.playerBody.position.lerp(G.body.pos, 0.25);
  G.playerBody.rotation.y += (G.body.vel.x * 0.3 - G.playerBody.rotation.y) * 0.1;
  const tiltZ = -G.body.vel.x * 0.15;
  G.playerBody.rotation.z += (tiltZ - G.playerBody.rotation.z) * 0.12;

  // ‚îÄ Launch gauge mechanic ‚îÄ
  const canCharge = G.left.hooked && G.right.hooked;
  const chargingNow = canCharge && G.keys['s'] && G.keys['ArrowDown'];

  if(chargingNow){
    G.launchCharging = true;
    G.launchCharge = Math.min(100, G.launchCharge + 2.2);
    // Sound build-up
    if(G.launchCharge > 5 && Math.random()<0.12){
      playSFX(200 + G.launchCharge*3, 0.04, 'sawtooth', 0.06 + G.launchCharge*0.001);
    }
  } else if(G.launchCharging){
    // RELEASE! Launch with power proportional to charge
    if(G.launchCharge > 8){
      const pwr = G.launchCharge / 100;
      G.body.vel.y = 4 + pwr * 14;
      G.body.vel.x *= 0.2;
      releaseGrab(G.left); releaseGrab(G.right);
      G.screenShake = 0.5 + pwr * 2.0;
      const col = pwr > 0.6 ? 0xFF4444 : (pwr > 0.3 ? 0xFFD000 : 0x44FF88);
      spawnParticles(G.body.pos, col, Math.floor(8 + pwr*20), 0.15 + pwr*0.3);
      playSFX(300 + pwr*500, 0.18, 'sine', 0.2 + pwr*0.15);
      playSFX(150 + pwr*200, 0.12, 'sawtooth', 0.15);
      $('flash').style.opacity = 0.1 + pwr*0.35;
      setTimeout(()=>$('flash').style.opacity=0, 80 + pwr*80);
    }
    G.launchCharge = 0;
    G.launchCharging = false;
  } else {
    // Decay charge quickly when not held
    G.launchCharge = Math.max(0, G.launchCharge - 4);
    if(!canCharge) G.launchCharging = false;
  }

  // Show/hide gauge
  if(G.launchCharge > 2){
    $('launchGauge').classList.add('show');
    $('launchFill').style.width = G.launchCharge + '%';
  } else {
    $('launchGauge').classList.remove('show');
  }

  // ‚îÄ Ambient environment particles ‚îÄ
  updateEnvParticles();

  // ‚îÄ Checkpoints ‚îÄ
  for(const cp of G.checkpoints){
    if(cp.userData.triggered) continue;
    if(Math.abs(G.body.pos.y - cp.position.y) < 4 &&
       Math.abs(G.body.pos.x - cp.position.x) < 5){
      cp.userData.triggered = true;
      G.respawnPos = V3(0, cp.position.y+3, 2);
      G.checkpointIdx++;
      playCheckpoint();
      showCheckpointFlash();
    }
  }

  // ‚îÄ Stage change ‚îÄ
  const newStage = Math.min(STAGES.length-1, STAGES.findIndex(s=>G.body.pos.y>=s.yMin && G.body.pos.y<s.yMax));
  const si = newStage < 0 ? STAGES.length-1 : newStage;
  if(si !== G.stageIdx){
    G.stageIdx = si;
    unlockStage(si);
    updateStageLights(si);
    sunLight.position.y = G.body.pos.y + 100;
    backLight.position.y = G.body.pos.y + 80;
  }
}

// ‚îÄ‚îÄ‚îÄ ENVIRONMENT PARTICLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateEnvParticles(){
  if(!G.envParticles) return;
  const si = G.stageIdx;
  const bp = G.body.pos;

  if(si===1 && Math.random()<0.25){ // Volcanic sparks
    spawnParticles(V3(bp.x+(Math.random()-0.5)*25, bp.y+(Math.random()-0.5)*20, -8+Math.random()*5), 0xFF4400, 3, 0.2);
  }
  if(si===2 && Math.random()<0.2){ // Neon rain
    const x = bp.x+(Math.random()-0.5)*40;
    const y = bp.y+18+Math.random()*8;
    const z = bp.z+(Math.random()-0.5)*5;
    const geo = new THREE.CylinderGeometry(0.03,0.03,0.8,4);
    const col = Math.random()<0.5?0x9B4DFF:0x00FFE5;
    const mat = new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.8});
    const drop = new THREE.Mesh(geo,mat);
    drop.position.set(x,y,z);
    scene.add(drop);
    G.envParticles.push({mesh:drop,life:1.0,vel:V3(0,-0.8,0)});
  }
  if(si===3 && Math.random()<0.12){ // Space debris
    const x = bp.x+(Math.random()-0.5)*60;
    const y = bp.y+(Math.random()-0.5)*30;
    const col = Math.random()<0.5?0x4466FF:0x8888FF;
    const geo = new THREE.BoxGeometry(0.3,0.3,0.3);
    const mat = new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.6});
    const d = new THREE.Mesh(geo,mat);
    d.position.set(x,y,-20+Math.random()*10);
    scene.add(d);
    G.envParticles.push({mesh:d,life:1.0,vel:V3((Math.random()-0.5)*0.05,-0.02,0)});
  }

  for(let i=G.envParticles.length-1;i>=0;i--){
    const p = G.envParticles[i];
    p.life -= 0.012;
    p.mesh.position.add(p.vel);
    p.mesh.material.opacity = p.life*0.8;
    if(p.life<=0||Math.abs(p.mesh.position.y-bp.y)>35){
      scene.remove(p.mesh);
      G.envParticles.splice(i,1);
    }
  }
}


function updateHand(hand, ku, kd, kl, kr, isHooked, otherHooked, grav){
  const speed = isHooked ? 0.12 : 0.28; // much faster

  if(!isHooked){
    if(G.keys[ku]) hand.vel.y += speed;
    if(G.keys[kd]) hand.vel.y -= speed;
    if(G.keys[kl]) hand.vel.x -= speed;
    if(G.keys[kr]) hand.vel.x += speed;

    // Very light gravity on free hand so it floats up easily
    hand.vel.y -= grav * 0.15;
    hand.vel.multiplyScalar(0.84);

    hand.pos.add(hand.vel);
    hand.pos.add(hand.swingMom);
    hand.swingMom.multiplyScalar(0.93);

    // Wide reach bounds
    hand.pos.x = clamp(hand.pos.x, -28, 28);
    hand.pos.y = clamp(hand.pos.y, G.body.pos.y-3, G.body.pos.y+22);
    hand.pos.z = clamp(hand.pos.z, -8, 10);

    // ‚îÄ‚îÄ WALL MAGNETISM: gently pull toward nearest hold above ‚îÄ‚îÄ
    if(hand.nearHold){
      const toHold = V3().subVectors(hand.nearHold.position, hand.pos);
      const dist = toHold.length();
      if(dist < 9){
        const strength = (1 - dist/9) * 0.018; // gentle pull
        hand.pos.addScaledVector(toHold.normalize(), strength);
      }
    } else {
      // Drift z toward wall when no hold nearby
      hand.pos.z += (-6 - hand.pos.z) * 0.012;
    }
  } else {
    // Hooked: lerp to hold position
    const hp = hand.hookHold.position;
    hand.pos.lerp(hp, 0.3);
    hand.vel.set(0,0,0);

    // Move with WASD/arrows as micro-adjustments
    if(G.keys[ku]) G.body.vel.y += 0.04;
    if(G.keys[kd]) G.body.vel.y -= 0.015;
    if(G.keys[kl]) G.body.vel.x -= 0.03;
    if(G.keys[kr]) G.body.vel.x += 0.03;
  }

  hand.group.position.lerp(hand.pos, 0.35);

  // Orient crowbar toward hook point or forward
  if(isHooked && hand.hookHold){
    const target = hand.hookHold.position.clone().sub(hand.pos).normalize();
    const angle = Math.atan2(target.x, target.y);
    hand.group.rotation.z = -angle * 0.5;
    hand.group.rotation.y = Math.atan2(-target.x, target.z) * 0.3;
  } else {
    hand.group.rotation.z *= 0.9;
    hand.group.rotation.y *= 0.9;
  }

  hand.group.rotation.x = Math.sin(Date.now()*0.002) * 0.05;

  // Detect nearby holds
  hand.nearHold = null;
  let nearDist = GRAB_RADIUS;
  for(const h of G.holds){
    if(h.userData.grabbed) continue;
    const d = hand.pos.distanceTo(h.position);
    if(d < nearDist){ hand.nearHold = h; nearDist = d; }
  }
}

// ‚îÄ‚îÄ‚îÄ CAMERA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateCamera(){
  const sens = 0.0018;

  // Screen shake
  const shake = G.screenShake;
  const sx = (Math.random()-0.5)*shake*0.4;
  const sy = (Math.random()-0.5)*shake*0.4;
  G.screenShake *= 0.88;

  if(G.camMode === 'first'){
    // ‚îÄ‚îÄ FIRST PERSON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Mouse look in first person
    G.fpYaw   -= G.mouseX * sens;
    G.fpPitch -= G.mouseY * sens;
    // Pitch range: looking mostly upward (0.2 = slight up, 1.4 = straight up, PI*0.48 = almost behind)
    G.fpPitch = clamp(G.fpPitch, -0.1, PI * 0.48);
    G.mouseX = 0; G.mouseY = 0;

    // Camera sits at character head position
    camera.position.set(
      G.body.pos.x + sx,
      G.body.pos.y + 2.0 + sy,  // eye level
      G.body.pos.z + 1.5        // slightly in front of body
    );

    camera.rotation.order = 'YXZ';
    camera.rotation.y = G.fpYaw;
    camera.rotation.x = G.fpPitch;  // positive = looking up

    // Hide the player body mesh in first person so it doesn't block view
    if(G.playerBody) G.playerBody.visible = false;

  } else {
    // ‚îÄ‚îÄ THIRD PERSON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    G.camYaw   -= G.mouseX * sens;
    G.camPitch -= G.mouseY * sens;
    G.camPitch  = clamp(G.camPitch, -PI*0.4, PI*0.35);
    G.mouseX = 0; G.mouseY = 0;

    G.camTargetY += (G.body.pos.y - G.camTargetY) * 0.08;

    const cy = G.camYaw;
    const cp = G.camPitch;
    const dist = G.camDist;

    camera.position.set(
      G.body.pos.x + Math.sin(cy)*Math.cos(cp)*dist + sx,
      G.camTargetY + Math.sin(cp)*dist + 2 + sy,
      G.body.pos.z + Math.cos(cy)*Math.cos(cp)*dist
    );

    camera.rotation.order = 'YXZ';
    camera.rotation.y = cy;
    camera.rotation.x = cp;

    if(G.playerBody) G.playerBody.visible = true;
  }

  // Moving lights follow player
  sunLight.position.set(20, G.body.pos.y+120, 30);
  backLight.position.set(-25, G.body.pos.y+80, -40);
  fillLight.position.set(30, G.body.pos.y+50, 30);
}

// ‚îÄ‚îÄ‚îÄ HUD UPDATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD(){
  $('hHeight').textContent = G.maxHeight+'m';
  $('hGrabs').textContent = G.grabs;

  const t = (Date.now()-G.startTime)/1000;
  const m = Math.floor(t/60);
  const s = Math.floor(t%60).toString().padStart(2,'0');
  $('hTime').textContent = `${m}:${s}`;

  const bar = $('stBar');
  bar.style.width = G.stamina+'%';
  bar.classList.toggle('low', G.stamina < 22);

  const si = G.stageIdx;
  $('stageName').textContent = STAGES[si].name;
  $('stageProgress').textContent = `STAGE ${si+1} / 4`;

  // Grab hints
  $('chipL').classList.toggle('show', !!G.left.nearHold && !G.left.hooked);
  $('chipR').classList.toggle('show', !!G.right.nearHold && !G.right.hooked);
}

// ‚îÄ‚îÄ‚îÄ CHECKPOINT FLASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showCheckpointFlash(){
  const cf = $('cpFlash');
  const cm = $('cpMsg');
  cf.style.opacity=1; cm.style.opacity=1;
  setTimeout(()=>{ cf.style.opacity=0; cm.style.opacity=0; }, 1200);
}

// ‚îÄ‚îÄ‚îÄ DEATH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function die(){
  G.dead = true;
  G.phase = 'dead';
  document.exitPointerLock();
  $('hud').classList.remove('show');
  $('strip').classList.remove('show');

  $('dHeight').textContent = G.maxHeight+'m';
  const t = (Date.now()-G.startTime)/1000;
  $('dTime').textContent = `${Math.floor(t/60)}:${Math.floor(t%60).toString().padStart(2,'0')}`;
  $('dGrabs').textContent = G.grabs;

  $('deathScreen').classList.add('show');
  playFall();
  G.screenShake = 2.5;
}

function restartGame(){
  $('deathScreen').classList.remove('show');
  // Remove all scene objects
  scene.children.slice().forEach(c=>scene.remove(c));
  G = null;
  startGame();
}

function respawnAtCheckpoint(){
  // Respawn from last checkpoint without full restart
  G.dead = false;
  G.phase = 'playing';
  G.body.pos.copy(G.respawnPos);
  G.body.vel.set(0,0,0);
  G.left.pos.copy(G.respawnPos).add(V3(-2.5,2,0));
  G.right.pos.copy(G.respawnPos).add(V3(2.5,2,0));
  G.left.hooked = false; G.left.hookHold = null;
  G.right.hooked = false; G.right.hookHold = null;
  G.stamina = 100;
  G.screenShake = 0;
  $('deathScreen').classList.remove('show');
  $('hud').classList.add('show');
  $('strip').classList.add('show');
  renderer.domElement.requestPointerLock();
}

function showMenu(){
  $('deathScreen').classList.remove('show');
  $('hud').classList.remove('show');
  $('strip').classList.remove('show');
  $('menu').classList.remove('hide');
  scene.children.slice().forEach(c=>scene.remove(c));
  G = null;
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let lastTime = 0;

function gameLoop(ts=0){
  requestAnimationFrame(gameLoop);
  const dt = Math.min((ts-lastTime)/16.67, 3);
  lastTime = ts;

  if(!G){ renderer.render(scene, camera); return; }
  if(G.paused || G.dead){ renderer.render(scene, camera); return; }

  updatePhysics(dt);
  updateCamera();
  updateParticles();
  updateHUD();

  // Pulsing holds + slow rotation on crystals
  const t = Date.now() * 0.002;
  for(const h of G.holds){
    const pulse = 0.5 + Math.sin(t + h.position.y*0.1)*0.5;
    if(h.userData.light) h.userData.light.intensity = 0.5 + pulse*0.6;
    if(h.userData.type==='crystal' && h.userData.mainMesh){
      h.userData.mainMesh.rotation.y += 0.008;
      h.userData.mainMesh.rotation.x += 0.004;
    }
    // Pulse emissive intensity on hold mesh
    if(h.userData.mainMesh && h.userData.mainMesh.material){
      h.userData.mainMesh.material.emissiveIntensity = 0.4 + pulse*0.5;
    }
  }

  renderer.render(scene, camera);
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
buildStarfield(); // galaxy multi-layer
renderer.setClearColor(0x05030A);
renderer.render(scene, camera);

// Animate menu galaxy
(function menuLoop(){
  if(G) return;
  requestAnimationFrame(menuLoop);
  renderer.render(scene, camera);
  const t = Date.now() * 0.0001;
  scene.children.forEach(c=>{
    if(c.type==='Points') c.rotation.y += 0.00015;
    if(c.isMesh && c.material.map && c.material.transparent && c.geometry.type==='PlaneGeometry'){
      c.rotation.z += 0.00008;
      c.material.opacity = 0.45 + Math.sin(t + c.position.y*0.01)*0.12;
    }
  });
})();

</script>
</body>
</html>

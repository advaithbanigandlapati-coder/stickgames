<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><title>STICK BASKET</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; display:flex; align-items:center; justify-content:center;
       width:100vw; height:100vh; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STICK BASKET  |  2 players, first to 5
//  CYAN:   A/D move  W jump  S grab/shoot
//  ORANGE: â†/â†’ move  â†‘ jump  â†“ grab/shoot
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
const GW = 960, GH = 540;
canvas.width = GW; canvas.height = GH;
function resize() {
  const s = Math.min(window.innerWidth/GW, window.innerHeight/GH);
  canvas.style.width = GW*s+'px'; canvas.style.height = GH*s+'px';
}
window.addEventListener('resize', resize); resize();

// â”€â”€ STATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const S = {MENU:0, PLAYING:1, ROUND_END:2, GAMEOVER:3};
let state = S.MENU, scores = [0,0];
const WIN = 5;

// â”€â”€ PHYSICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let GRAV=0.46, WIND=0, JUMP_F=-14.0, BALL_BNC=0.60, TIMESC=1;
let DBL_PTS=false, BLACK_HOLE=false;
function resetPhysics() { GRAV=0.46;WIND=0;JUMP_F=-14.0;BALL_BNC=0.60;TIMESC=1;DBL_PTS=false;BLACK_HOLE=false; }

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys={}, pressed={};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) pressed[e.code]=true;
  keys[e.code]=true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { delete keys[e.code]; });
function clearPressed() { for (const k in pressed) delete pressed[k]; }

// â”€â”€ SPRING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Spring {
  constructor(k=0.30, d=0.65) { this.k=k; this.d=d; this.x=0; this.v=0; }
  tick(dt=1) { this.v += (-this.k*this.x - this.d*this.v)*dt; this.x += this.v*dt; }
  kick(dv)   { this.v += dv; }
  reset()    { this.x=0; this.v=0; }
}

// â”€â”€ STARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STARS = Array.from({length:200}, () => ({
  x:Math.random()*GW, y:Math.random()*GH,
  r:Math.random()*1.5+0.3, ph:Math.random()*Math.PI*2, spd:Math.random()*0.3+0.05
}));

// â”€â”€ ENVS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ENVS = [
  {name:'NEBULA ARENA',  bg:['#020210','#06061a'], floor:'#0c0c2e', glow:'#3344ff'},
  {name:'ASTEROID BELT', bg:['#090400','#160800'], floor:'#281200', glow:'#ff6600'},
  {name:'ION STORM',     bg:['#000d06','#001910'], floor:'#051a0e', glow:'#00ee77'},
  {name:'VOID SECTOR',   bg:['#040004','#0c000c'], floor:'#110015', glow:'#cc00ff'},
  {name:'SOLAR FLARE',   bg:['#0e0200','#1c0400'], floor:'#260e00', glow:'#ff3300'},
];
let envIdx=0;

// â”€â”€ LAYOUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FLOOR_Y = GH-60;
const LAYOUTS = [
  [{x:0,y:FLOOR_Y,w:GW,h:60}],
  [{x:0,y:FLOOR_Y,w:GW,h:60},{x:GW/2-65,y:FLOOR_Y-115,w:130,h:16}],
  [{x:0,y:FLOOR_Y,w:GW,h:60},{x:25,y:FLOOR_Y-100,w:130,h:16},{x:GW-155,y:FLOOR_Y-100,w:130,h:16}],
  [{x:0,y:FLOOR_Y,w:GW,h:60},{x:GW/2-45,y:FLOOR_Y-145,w:90,h:16},{x:75,y:FLOOR_Y-90,w:110,h:16},{x:GW-185,y:FLOOR_Y-90,w:110,h:16}],
];
let plats = [];

// â”€â”€ HOOPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HOOP_R   = 28;   // hoop ring radius
const RIM_R    = 5;    // rim post collision radius
const HOOPS = [
  {x:118, y:238, team:0, wave:0},
  {x:GW-118, y:238, team:1, wave:0},
];
let scoreCool = 0;

// â”€â”€ BALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ball = {
  x:GW/2, y:0, vx:0, vy:0, r:11,
  angle:0, trail:[], holder:null, prevY:0,
  sqX: new Spring(0.45,0.60),
  sqY: new Spring(0.45,0.60),
};
function resetBall() {
  ball.holder=null;
  ball.x=GW/2; ball.y=GH/2-60;
  ball.vx=(Math.random()-0.5)*5; ball.vy=-5;
  ball.r=11; ball.angle=0; ball.trail=[];
  ball.prevY=ball.y; ball.sqX.reset(); ball.sqY.reset();
}

// â”€â”€ PLAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Player {
  constructor(x,y,team,slot) {
    this.sx=x; this.sy=y; this.team=team; this.slot=slot;
    this.x=x; this.y=y; this.vx=0; this.vy=0;
    this.onGround=false; this.wasGround=false;
    this.facing=team===0?1:-1;
    this.legPhase=0; this.scale=1; this.fric=0.80;
    // Body dims (head center is at this.y)
    this.HR=12; this.BL=37; this.AL=26; this.LL=26;
    // Ragdoll springs
    this.sp = {
      squash: new Spring(0.38, 0.60), // body squash/stretch
      lean:   new Spring(0.20, 0.56), // body tilt
      headX:  new Spring(0.28, 0.52), // head sway L/R
      headY:  new Spring(0.30, 0.54), // head bob U/D
      armF:   new Spring(0.16, 0.46), // front arm angle
      armB:   new Spring(0.16, 0.46), // back arm angle
      legW:   new Spring(0.26, 0.58), // leg spread
    };
    this.col   = team===0 ? '#00ccff' : '#ff6600';
    this.dark  = team===0 ? '#003d55' : '#552200';
    this.visor = team===0 ? '#002244' : '#441100';
  }

  // foot = bottom of legs
  get foot()    { return this.y + (this.HR + this.BL + this.LL) * this.scale; }
  get bodyMid() { return this.y + (this.HR + this.BL*0.5) * this.scale; }
  get radius()  { return 15 * this.scale; }

  reset() {
    this.x=this.sx; this.y=this.sy; this.vx=0; this.vy=0;
    this.onGround=false; this.wasGround=false;
    this.facing=this.team===0?1:-1; this.legPhase=0; this.scale=1; this.fric=0.80;
    for (const sp of Object.values(this.sp)) sp.reset();
  }

  update(dt) {
    const left  = this.team===0 ? keys['KeyA'] : keys['ArrowLeft'];
    const right = this.team===0 ? keys['KeyD'] : keys['ArrowRight'];
    const jump  = this.team===0 ? pressed['KeyW'] : pressed['ArrowUp'];
    const grab  = this.team===0 ? pressed['KeyS'] : pressed['ArrowDown'];

    const spd = 5.5 * this.scale;
    if (left)  { this.vx -= 1.9*dt; this.facing=-1; }
    if (right) { this.vx += 1.9*dt; this.facing= 1; }
    if (!left && !right) this.vx *= this.fric;
    this.vx = Math.max(-spd, Math.min(spd, this.vx));

    if (jump && this.onGround) {
      this.vy = JUMP_F * this.scale;
      this.sp.squash.kick(0.65);
      this.sp.lean.kick(this.vx * 0.05);
      this.sp.headY.kick(-0.8);
      this.sp.armF.kick(-0.9); this.sp.armB.kick(-0.9);
    }
    if (grab) this.grabShoot();

    this.wasGround = this.onGround;
    const prevVy = this.vy;

    this.vy += GRAV * dt;
    this.vx += WIND * dt;
    this.x  += this.vx * dt;
    this.y  += this.vy * dt;

    // Leg walk cycle
    if (this.onGround && Math.abs(this.vx) > 0.3)
      this.legPhase += 0.14 * Math.abs(this.vx) * dt;

    // Tick all springs
    for (const sp of Object.values(this.sp)) sp.tick(dt);

    // Running lean
    if (this.onGround) this.sp.lean.kick(this.vx * 0.011);

    // â”€â”€ Platform collision â”€â”€
    this.onGround = false;
    for (const pl of plats) {
      const hw = this.radius;
      if (this.x+hw > pl.x && this.x-hw < pl.x+pl.w) {
        // Land on top
        if (prevVy >= 0 && this.foot > pl.y && this.foot-prevVy*dt <= pl.y+6) {
          this.y = pl.y - (this.HR+this.BL+this.LL)*this.scale;
          const landVy = this.vy; this.vy = 0; this.onGround = true;
          if (!this.wasGround) { // just landed
            const imp = Math.min(Math.abs(landVy)*0.042, 1.5);
            this.sp.squash.kick(-imp * 1.25);
            this.sp.headY.kick( imp * 1.10);
            this.sp.headX.kick((Math.random()-0.5)*imp*0.8);
            this.sp.armF.kick( imp * 0.70);
            this.sp.armB.kick(-imp * 0.70);
            this.sp.legW.kick( imp * 0.55);
            if (imp > 0.5) burst(this.x, pl.y, this.col+'88', 4);
          }
        }
        // Head bump
        if (this.vy < 0 && this.y < pl.y+pl.h && this.y-prevVy*dt > pl.y) {
          this.y = pl.y+pl.h; this.vy = Math.abs(this.vy)*0.3;
          this.sp.headY.kick(-0.7);
        }
      }
    }
    // Walls
    const hw = this.radius;
    if (this.x < hw)    { this.x=hw;    this.vx=Math.abs(this.vx)*0.4;  this.sp.lean.kick( 0.55*this.facing); }
    if (this.x > GW-hw) { this.x=GW-hw; this.vx=-Math.abs(this.vx)*0.4; this.sp.lean.kick(-0.55*this.facing); }
    if (this.y < -280)  { this.y=-280; this.vy=2; }
  }

  grabShoot() {
    if (ball.holder === this) {
      this.shoot();
    } else if (ball.holder === null) {
      const dx=ball.x-this.x, dy=ball.y-this.bodyMid;
      if (Math.sqrt(dx*dx+dy*dy) < this.radius*2.8+ball.r) {
        ball.holder = this;
        this.sp.armF.kick(-1.3); this.sp.armB.kick(-0.8);
        this.sp.headY.kick(-0.5);
        burst(ball.x, ball.y, this.col, 5);
      }
    }
  }

  shoot() {
    if (ball.holder !== this) return;
    ball.holder = null;
    const tgt = HOOPS[1-this.team];
    const bx = this.x + this.facing*(this.radius+ball.r+2);
    const by = this.y - 6*this.scale;
    ball.x=bx; ball.y=by; ball.prevY=by;
    const dx=tgt.x-bx, dy=tgt.y-by;
    const dist=Math.sqrt(dx*dx+dy*dy);
    const t = 22 + dist*0.040;
    ball.vx = dx/t + this.vx*0.22;
    ball.vy = (dy - 0.5*GRAV*t*t) / t;
    // Shooting reaction
    this.sp.lean.kick(this.facing*1.0);
    this.sp.squash.kick(0.50);
    this.sp.headY.kick(-0.9);
    this.sp.armF.kick(-1.8); this.sp.armB.kick(-1.4);
    burst(bx, by, this.col, 9);
  }

  hitByBall(nx, ny, str) {
    this.sp.lean.kick(nx * str * 0.5 * this.facing);
    this.sp.headX.kick(nx * str * 0.38);
    this.sp.headY.kick(Math.abs(ny) * str * 0.45);
    this.sp.squash.kick(str * 0.28);
    this.sp.armF.kick(ny * str * 0.45);
    this.sp.armB.kick(-ny * str * 0.45);
  }

  carryPos() {
    return {
      x: this.x + this.facing*(this.radius+ball.r+2),
      y: this.y - 5*this.scale
    };
  }

  draw() {
    const f = this.facing;
    const s = this.scale;
    const sq = this.sp.squash.x;
    const {HR,BL,AL,LL} = this;

    ctx.save();
    ctx.translate(this.x, this.y);
    // Body lean (follows movement direction)
    ctx.rotate(this.sp.lean.x * 0.38 * f);
    // Squash & stretch  (sq<0=compressed, sq>0=stretched)
    ctx.scale(s*(1 - sq*0.14), s*(1 + sq*0.30));

    ctx.shadowColor=this.col; ctx.shadowBlur=14;
    ctx.lineCap='round'; ctx.lineJoin='round';

    // â”€â”€ HEAD (with wobble offsets) â”€â”€
    ctx.save();
    ctx.translate(this.sp.headX.x*5*f, this.sp.headY.x*5);
    ctx.fillStyle=this.col;
    ctx.beginPath(); ctx.arc(0,0,HR,0,Math.PI*2); ctx.fill();
    // Helmet dome
    ctx.fillStyle=this.dark;
    ctx.beginPath(); ctx.arc(f,-1,HR*0.63,Math.PI*1.05,Math.PI*2); ctx.fill();
    // Visor
    ctx.fillStyle=this.visor;
    ctx.beginPath(); ctx.arc(f*2,-2,HR*0.37,Math.PI*1.12,Math.PI*1.88); ctx.fill();
    // Shine
    ctx.fillStyle='rgba(255,255,255,0.68)';
    ctx.beginPath(); ctx.arc(-f*1.5,-4.5,HR*0.13,0,Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.strokeStyle=this.col; ctx.lineWidth=7;

    // â”€â”€ BODY â”€â”€
    ctx.beginPath(); ctx.moveTo(0,HR); ctx.lineTo(0,HR+BL); ctx.stroke();

    const sY = HR + BL*0.28; // shoulder
    const hY = HR + BL;      // hip

    // â”€â”€ ARMS â”€â”€
    const holding = ball.holder===this;
    const walkA = this.onGround && Math.abs(this.vx)>0.25 ? Math.sin(this.legPhase)*0.30 : 0;
    const afSpring = this.sp.armF.x, abSpring = this.sp.armB.x;

    // Front arm (facing direction)
    ctx.beginPath(); ctx.moveTo(0, sY);
    if (holding) {
      ctx.lineTo(f*AL*0.68, sY - AL*0.78); // raised overhead
    } else {
      ctx.lineTo(f*(AL*0.78 + afSpring*AL*0.12), sY + AL*(0.44 - walkA*0.38));
    }
    ctx.stroke();

    // Back arm
    ctx.beginPath(); ctx.moveTo(0, sY);
    ctx.lineTo(-f*(AL*0.72 + abSpring*AL*0.12), sY + AL*(0.46 + walkA*0.38));
    ctx.stroke();

    // â”€â”€ LEGS â”€â”€
    const lSwing = Math.sin(this.legPhase) * (this.onGround && Math.abs(this.vx)>0.25 ? 0.50 : 0.10);
    const lSpd   = 0.42 + this.sp.legW.x*0.06;

    ctx.beginPath(); ctx.moveTo(0, hY);
    ctx.lineTo( f*LL*(lSpd + lSwing*0.52), hY+LL); ctx.stroke();

    ctx.beginPath(); ctx.moveTo(0, hY);
    ctx.lineTo(-f*LL*(lSpd - lSwing*0.52), hY+LL); ctx.stroke();

    // â”€â”€ HOLDING AURA â”€â”€
    if (holding) {
      ctx.globalAlpha = 0.36 + 0.26*Math.sin(Date.now()*0.013);
      ctx.strokeStyle=this.col; ctx.lineWidth=2; ctx.shadowBlur=20;
      ctx.beginPath(); ctx.arc(0,-HR*0.1,HR*1.75,0,Math.PI*2); ctx.stroke();
    }

    ctx.restore();
  }
}

// â”€â”€ COLLISIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playerCollisions() {
  for (let i=0; i<players.length; i++) {
    for (let j=i+1; j<players.length; j++) {
      const a=players[i], b=players[j];
      const dx=b.x-a.x, dy=b.bodyMid-a.bodyMid;
      const dist=Math.sqrt(dx*dx+dy*dy);
      const minD=a.radius+b.radius;
      if (dist<minD && dist>0.01) {
        const nx=dx/dist, ov=(minD-dist)*0.55;
        a.x-=nx*ov; b.x+=nx*ov;
        const rv=(b.vx-a.vx)*nx;
        if (rv<0) {
          const imp=rv*0.65;
          a.vx+=imp; b.vx-=imp;
          a.sp.lean.kick( nx*0.45*a.facing);
          b.sp.lean.kick(-nx*0.45*b.facing);
          a.sp.headX.kick( nx*0.30);
          b.sp.headX.kick(-nx*0.30);
        }
      }
    }
  }
}

function ballPlayerPhysics() {
  if (ball.holder) return;
  for (const p of players) {
    const dx=ball.x-p.x, dy=ball.y-p.bodyMid;
    const dist=Math.sqrt(dx*dx+dy*dy);
    const minD=ball.r + p.radius*1.05;
    if (dist<minD && dist>0.01) {
      const nx=dx/dist, ny=dy/dist;
      // Push out
      const ov=minD-dist;
      ball.x+=nx*ov*0.72; ball.y+=ny*ov*0.72;
      const rv=(ball.vx-p.vx)*nx+(ball.vy-p.vy)*ny;
      if (rv<0) {
        const imp=-rv*1.55;
        ball.vx+=nx*imp; ball.vy+=ny*imp;
        p.vx-=nx*imp*0.28; p.vy-=ny*imp*0.18;
        const str=Math.min(imp*0.14,1.2);
        p.hitByBall(nx,ny,str);
        ball.sqX.kick(nx*str*2.2); ball.sqY.kick(ny*str*2.2);
      }
    }
  }
}

// â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let parts=[];
function burst(x,y,col,n=14) {
  for (let i=0;i<n;i++) {
    const a=Math.random()*Math.PI*2, sp=Math.random()*9+2;
    parts.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-2.5,
      r:Math.random()*5+2,col,life:1,dec:0.024+Math.random()*0.02});
  }
}
function tickParts() {
  parts=parts.filter(p=>p.life>0);
  for (const p of parts) { p.x+=p.vx; p.y+=p.vy; p.vy+=0.22; p.life-=p.dec; p.r*=0.95; }
}
function drawParts() {
  for (const p of parts) {
    ctx.save(); ctx.globalAlpha=p.life*p.life;
    ctx.fillStyle=p.col; ctx.shadowColor=p.col; ctx.shadowBlur=8;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// â”€â”€ WILDCARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WCS=[
  {icon:'ðŸŒŒ',name:'ZERO-G',       desc:'Gravity nearly gone!',      col:'#00ffff',apply(){GRAV=0.11;JUMP_F=-7.5;}},
  {icon:'â­',name:'NEUTRON STAR',  desc:'Crushing gravity!',         col:'#ff4444',apply(){GRAV=1.1;JUMP_F=-20;}},
  {icon:'ðŸ’¨',name:'SOLAR WIND â†’',  desc:'Rightward push!',           col:'#ffaa00',apply(){WIND=0.32;}},
  {icon:'ðŸ’¨',name:'SOLAR WIND â†',  desc:'Leftward push!',            col:'#ffaa00',apply(){WIND=-0.32;}},
  {icon:'ðŸ”®',name:'HYPER BOUNCE',  desc:'Ball bounces insane!',      col:'#ff00ff',apply(){BALL_BNC=0.97;ball.r=14;}},
  {icon:'ðŸŒŸ',name:'MEGA ORB',      desc:'Enormous ball!',            col:'#ffaa44',apply(){ball.r=22;}},
  {icon:'âš¡',name:'MICRO ORB',     desc:'Microscopic ball!',         col:'#88ff88',apply(){ball.r=5;}},
  {icon:'âœ¨',name:'DOUBLE POINTS', desc:'Next score = 2 pts!',       col:'#ffff00',apply(){DBL_PTS=true;}},
  {icon:'ðŸ‘¾',name:'GIANT MODE',    desc:'Colossal players!',         col:'#88aaff',apply(){players.forEach(p=>p.scale=1.6);}},
  {icon:'ðŸ”¬',name:'SHRINK RAY',    desc:'Tiny players!',             col:'#ff88ff',apply(){players.forEach(p=>p.scale=0.55);}},
  {icon:'â„ï¸',name:'ICE FIELD',     desc:'Zero friction!',            col:'#aaddff',apply(){players.forEach(p=>p.fric=0.998);}},
  {icon:'ðŸ•³ï¸',name:'BLACK HOLE',    desc:'Ball pulled to center!',    col:'#9900ff',apply(){BLACK_HOLE=true;}},
  {icon:'â±ï¸',name:'TIME WARP',     desc:'Slow motion!',              col:'#dd88ff',apply(){TIMESC=0.38;}},
  {icon:'ðŸš€',name:'WARP SPEED',    desc:'Blink and miss it!',        col:'#ff3388',apply(){TIMESC=1.90;}},
  {icon:'ðŸ‘ï¸',name:'DARK MATTER',   desc:'Ball nearly invisible!',    col:'#334455',apply(){}},
];
let curWC=null;
let ann=null, annT=0;
function announce(text,col,sub='') { ann={text,col,sub}; annT=220; }

// â”€â”€ GAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let players=[], roundEndT=0;
function spawnPlayers() {
  // Spawn slightly above floor so landing animation plays
  const spawnY = FLOOR_Y - 12 - 37 - 26 - 40; // foot lands on FLOOR_Y after 40px drop
  players = [
    new Player(148,  spawnY, 0, 0),
    new Player(262,  spawnY, 0, 1),
    new Player(GW-262, spawnY, 1, 2),
    new Player(GW-148, spawnY, 1, 3),
  ];
}

function startGame() {
  scores=[0,0]; envIdx=0;
  plats=LAYOUTS[0].map(p=>({...p}));
  resetPhysics(); resetBall(); spawnPlayers(); parts=[];
  curWC=null; annT=0; scoreCool=0;
  for (const h of HOOPS) h.wave=0;
  state=S.PLAYING;
  announce('ðŸš€ GAME START!','#ffffff','CYAN: WASD   |   ORANGE: ARROWS');
}

function endRound(winner) {
  const pts=DBL_PTS?2:1;
  scores[winner]+=pts;
  ball.holder=null;
  const hoop=HOOPS[1-winner];
  hoop.wave=1;
  burst(hoop.x, hoop.y, winner===0?'#00ccff':'#ff6600', 45);
  burst(hoop.x, hoop.y, '#ffffff', 15);
  announce('ðŸ€ BASKET!', winner===0?'#00ccff':'#ff6600',
    (winner===0?'TEAM CYAN':'TEAM ORANGE')+(pts>1?' â€” DOUBLE POINTS!':''));
  if (scores[winner]>=WIN) { state=S.GAMEOVER; return; }
  state=S.ROUND_END; roundEndT=130;
}

function nextRound() {
  envIdx=(envIdx+1)%ENVS.length;
  plats=LAYOUTS[envIdx%LAYOUTS.length].map(p=>({...p}));
  resetPhysics(); resetBall(); spawnPlayers(); parts=[]; scoreCool=0;
  for (const h of HOOPS) h.wave=0;
  const wc=WCS[Math.floor(Math.random()*WCS.length)];
  curWC=wc; wc.apply();
  announce(wc.icon+' '+wc.name, wc.col, wc.desc);
}

// â”€â”€ UPDATE BALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateBall(dt) {
  ball.sqX.tick(dt); ball.sqY.tick(dt);

  if (ball.holder) {
    const cp=ball.holder.carryPos();
    ball.x=cp.x; ball.y=cp.y;
    ball.vx=ball.holder.vx; ball.vy=ball.holder.vy;
    ball.trail=[]; ball.prevY=ball.y;
    return;
  }

  ball.prevY = ball.y;

  // Physics
  ball.vx *= 0.9995;   // tiny air drag
  ball.vy *= 0.9995;
  ball.vy += GRAV * dt * 0.73;
  ball.vx += WIND * dt;
  ball.x  += ball.vx * dt;
  ball.y  += ball.vy * dt;
  ball.angle += ball.vx * 0.043 * dt;

  ball.trail.push({x:ball.x, y:ball.y});
  if (ball.trail.length>18) ball.trail.shift();

  // â”€â”€ Wall bounce â”€â”€
  if (ball.x-ball.r < 0) {
    ball.x=ball.r; ball.vx=Math.abs(ball.vx)*BALL_BNC;
    ball.sqX.kick(-1.8); burst(0,ball.y,ENVS[envIdx].glow,4);
  }
  if (ball.x+ball.r > GW) {
    ball.x=GW-ball.r; ball.vx=-Math.abs(ball.vx)*BALL_BNC;
    ball.sqX.kick( 1.8); burst(GW,ball.y,ENVS[envIdx].glow,4);
  }
  if (ball.y-ball.r < 0) {
    ball.y=ball.r; ball.vy=Math.abs(ball.vy)*BALL_BNC;
    ball.sqY.kick(-1.6);
  }

  // â”€â”€ Platform bounce â”€â”€
  for (const pl of plats) {
    if (ball.x+ball.r > pl.x && ball.x-ball.r < pl.x+pl.w) {
      if (ball.vy > 0 && ball.y+ball.r > pl.y && ball.y+ball.r-ball.vy*dt <= pl.y+10) {
        ball.y=pl.y-ball.r;
        const by=Math.abs(ball.vy)*BALL_BNC;
        ball.vy=-by; ball.vx*=0.91;
        ball.sqY.kick(by*0.14);
        if (by>2) burst(ball.x,pl.y,ENVS[envIdx].glow,3);
      }
    }
  }

  // â”€â”€ Hoop rim collision â”€â”€
  for (const h of HOOPS) {
    const rimPosts = [{x:h.x-HOOP_R,y:h.y},{x:h.x+HOOP_R,y:h.y}];
    for (const rp of rimPosts) {
      const dx=ball.x-rp.x, dy=ball.y-rp.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      const minD=ball.r+RIM_R;
      if (d<minD && d>0.01) {
        const nx=dx/d, ny=dy/d;
        ball.x=rp.x+nx*minD; ball.y=rp.y+ny*minD;
        const dot=ball.vx*nx+ball.vy*ny;
        if (dot<0) {
          ball.vx -= 2*dot*nx*BALL_BNC*0.80;
          ball.vy -= 2*dot*ny*BALL_BNC*0.80;
        }
        ball.sqX.kick(nx*1.6); ball.sqY.kick(ny*1.6);
        burst(rp.x, rp.y, '#ffcc66', 5);
      }
    }
    // Net wave decay
    if (h.wave>0.01) h.wave*=0.955; else h.wave=0;
  }

  // â”€â”€ Black hole â”€â”€
  if (BLACK_HOLE) {
    const dx=GW/2-ball.x, dy=GH/2-90-ball.y;
    const d=Math.max(1,Math.sqrt(dx*dx+dy*dy));
    ball.vx+=dx/d*0.88; ball.vy+=dy/d*0.88;
  }
}

// â”€â”€ SCORE CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ball scores when it crosses hoop.y from above, within the ring opening
function checkScore() {
  if (scoreCool>0) { scoreCool--; return; }
  if (ball.holder) return;
  for (const h of HOOPS) {
    const prevAbove = ball.prevY < h.y;
    const nowBelow  = ball.y   >= h.y;
    const inX       = Math.abs(ball.x - h.x) < HOOP_R - ball.r + 4;
    if (prevAbove && nowBelow && inX && ball.vy > 0) {
      scoreCool=80;
      endRound(1-h.team);
      return;
    }
  }
}

// â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBg() {
  const e=ENVS[envIdx];
  const g=ctx.createLinearGradient(0,0,0,GH);
  g.addColorStop(0,e.bg[0]); g.addColorStop(1,e.bg[1]);
  ctx.fillStyle=g; ctx.fillRect(0,0,GW,GH);
  const now=Date.now()*0.001;
  for (const s of STARS) {
    const a=0.2+0.8*((Math.sin(now*s.spd*8+s.ph)+1)*0.5);
    ctx.globalAlpha=a*0.85; ctx.fillStyle='#fff';
    if (s.r>1.1) { ctx.shadowColor='#fff'; ctx.shadowBlur=4; } else ctx.shadowBlur=0;
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
  const nb=ctx.createRadialGradient(GW*0.25,GH*0.45,0,GW*0.25,GH*0.45,240);
  nb.addColorStop(0,e.glow+'22'); nb.addColorStop(1,'transparent');
  ctx.fillStyle=nb; ctx.fillRect(0,0,GW,GH);
  const nb2=ctx.createRadialGradient(GW*0.75,GH*0.55,0,GW*0.75,GH*0.55,200);
  nb2.addColorStop(0,e.glow+'18'); nb2.addColorStop(1,'transparent');
  ctx.fillStyle=nb2; ctx.fillRect(0,0,GW,GH);
}

function drawPlatforms() {
  const e=ENVS[envIdx];
  for (const pl of plats) {
    const g=ctx.createLinearGradient(0,pl.y,0,pl.y+pl.h);
    g.addColorStop(0,e.floor); g.addColorStop(1,e.bg[1]);
    ctx.fillStyle=g; ctx.fillRect(pl.x,pl.y,pl.w,pl.h);
    ctx.save(); ctx.shadowColor=e.glow; ctx.shadowBlur=10;
    ctx.strokeStyle=e.glow; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(pl.x,pl.y); ctx.lineTo(pl.x+pl.w,pl.y); ctx.stroke();
    ctx.restore();
    if (pl.h>30) {
      ctx.strokeStyle=e.glow+'1e'; ctx.lineWidth=1;
      for (let x2=pl.x+80; x2<pl.x+pl.w; x2+=80) {
        ctx.beginPath(); ctx.moveTo(x2,pl.y); ctx.lineTo(x2,pl.y+pl.h); ctx.stroke();
      }
      ctx.save(); ctx.shadowColor=e.glow; ctx.shadowBlur=6;
      ctx.strokeStyle=e.glow+'55'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(GW/2,pl.y); ctx.lineTo(GW/2,pl.y+40); ctx.stroke();
      ctx.restore();
    }
  }
}

// â”€â”€ HOOP DRAWING (split for ball-through-hoop layering) â”€â”€
// The hoop is an oval ring viewed from a slight angle.
// "Back" half = upper arc (farther from viewer) â†’ drawn BEFORE ball.
// "Front" half = lower arc (closer to viewer)   â†’ drawn AFTER ball.
// This makes the ball appear to pass through the hoop opening.

function drawHoopBack(h) {
  const col=h.team===0?'#00ccff':'#ff6600';
  const {x,y}=h;
  const pulse=0.75+0.25*Math.sin(Date.now()*0.005);

  // Pole
  ctx.strokeStyle='#44446a'; ctx.lineWidth=3; ctx.lineCap='butt';
  ctx.beginPath(); ctx.moveTo(x,y+HOOP_R+4); ctx.lineTo(x,FLOOR_Y); ctx.stroke();

  // Backboard
  const side=h.team===0?-1:1;
  ctx.fillStyle='rgba(100,100,180,0.10)'; ctx.strokeStyle='rgba(120,120,200,0.32)'; ctx.lineWidth=1.5;
  ctx.fillRect(x+side*3-5, y-HOOP_R-28, 10, 50);
  ctx.strokeRect(x+side*3-5, y-HOOP_R-28, 10, 50);

  // Glow rings â€” back only (upper half arcs)
  for (let i=4; i>=1; i--) {
    ctx.save(); ctx.globalAlpha=0.07*i*pulse;
    ctx.strokeStyle=col; ctx.lineWidth=i*5; ctx.shadowColor=col; ctx.shadowBlur=18;
    ctx.beginPath();
    ctx.ellipse(x,y,HOOP_R+i*2,HOOP_R*0.28+i*0.5, 0, Math.PI,Math.PI*2);
    ctx.stroke(); ctx.restore();
  }

  // Back rim arc (top half: from PI to 2*PI = leftâ†’topâ†’right)
  ctx.save(); ctx.shadowColor=col; ctx.shadowBlur=15*pulse;
  ctx.strokeStyle=col; ctx.lineWidth=4.5;
  ctx.beginPath(); ctx.ellipse(x,y,HOOP_R,HOOP_R*0.28,0, Math.PI,Math.PI*2); ctx.stroke();
  ctx.restore();
}

function drawHoopFront(h) {
  const col=h.team===0?'#00ccff':'#ff6600';
  const {x,y,wave}=h;
  const pulse=0.75+0.25*Math.sin(Date.now()*0.005);

  // Front rim arc (bottom half: from 0 to PI = rightâ†’bottomâ†’left)
  // This draws on TOP of the ball, creating the through-hoop illusion
  ctx.save(); ctx.shadowColor=col; ctx.shadowBlur=20*pulse;
  ctx.strokeStyle=col; ctx.lineWidth=5.5;
  ctx.beginPath(); ctx.ellipse(x,y,HOOP_R,HOOP_R*0.28,0, 0,Math.PI); ctx.stroke();
  ctx.restore();

  // Rim debug dots (removed for release â€” useful for debugging rim collision)
  // ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(x-HOOP_R,y,RIM_R,0,Math.PI*2); ctx.fill();
  // ctx.beginPath(); ctx.arc(x+HOOP_R,y,RIM_R,0,Math.PI*2); ctx.fill();

  // Net with wave animation on score
  const now=Date.now()*0.025;
  ctx.strokeStyle=col+'60'; ctx.lineWidth=1.3; ctx.lineCap='round';
  for (let i=-3; i<=3; i++) {
    const wv=wave*Math.sin((i+3)*1.1+now)*3.5;
    ctx.beginPath();
    ctx.moveTo(x+i*(HOOP_R/3.3), y+HOOP_R*0.18);
    ctx.lineTo(x+i*(HOOP_R/4.8)+wv, y+22+wave*6);
    ctx.stroke();
  }
  // Horizontal net lines
  ctx.beginPath();
  ctx.moveTo(x-HOOP_R*0.72, y+8); ctx.lineTo(x+HOOP_R*0.72, y+8);
  ctx.moveTo(x-HOOP_R*0.54+wave*2, y+17+wave*4); ctx.lineTo(x+HOOP_R*0.54-wave*2, y+17+wave*4);
  ctx.stroke();
}

function drawBall() {
  const inv=curWC&&curWC.icon==='ðŸ‘ï¸';
  const alpha=inv?0.18:1;
  const scX=1+ball.sqX.x*0.24, scY=1+ball.sqY.x*0.24;

  // Trail
  for (let i=0; i<ball.trail.length; i++) {
    const tp=ball.trail[i];
    const a=(i/ball.trail.length)*0.42*alpha;
    ctx.save(); ctx.globalAlpha=a;
    ctx.fillStyle='#aa44ff'; ctx.shadowColor='#7700cc'; ctx.shadowBlur=6;
    ctx.beginPath(); ctx.arc(tp.x,tp.y,ball.r*(i/ball.trail.length)*0.82,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  ctx.save(); ctx.globalAlpha=alpha;

  // Outer glow
  const og=ctx.createRadialGradient(ball.x,ball.y,0,ball.x,ball.y,ball.r*3.2);
  og.addColorStop(0,'rgba(170,60,255,0.22)'); og.addColorStop(1,'transparent');
  ctx.fillStyle=og; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r*3.2,0,Math.PI*2); ctx.fill();

  // Core with squash deformation
  ctx.save();
  ctx.translate(ball.x, ball.y); ctx.rotate(ball.angle);
  ctx.scale(scX, scY);
  const bg=ctx.createRadialGradient(-ball.r*0.3,-ball.r*0.3,0,0,0,ball.r);
  bg.addColorStop(0,'#ffffff'); bg.addColorStop(0.25,'#cc88ff');
  bg.addColorStop(0.62,'#7700ee'); bg.addColorStop(1,'#2a004a');
  ctx.shadowColor='#bb44ff'; ctx.shadowBlur=22;
  ctx.fillStyle=bg; ctx.beginPath(); ctx.arc(0,0,ball.r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.22)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(-ball.r*0.72,0); ctx.lineTo(ball.r*0.72,0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,-ball.r*0.72); ctx.lineTo(0,ball.r*0.72); ctx.stroke();
  ctx.restore();

  ctx.restore();
}

function drawBlackHole() {
  if (!BLACK_HOLE) return;
  const bx=GW/2, by=GH/2-90, now=Date.now()*0.001;
  ctx.save(); ctx.globalAlpha=0.7;
  for (let i=5; i>0; i--) {
    ctx.strokeStyle=`hsl(${260+i*22},100%,${35+i*9}%)`;
    ctx.lineWidth=i*1.5; ctx.shadowColor=`hsl(${260+i*22},100%,50%)`; ctx.shadowBlur=12;
    ctx.beginPath(); ctx.arc(bx,by,10+i*9,now*i*0.65,now*i*0.65+Math.PI*1.5); ctx.stroke();
  }
  ctx.restore();
}

function drawHUD() {
  const c0='#00ccff', c1='#ff6600';

  // Score boxes
  ctx.save();
  ctx.fillStyle=c0+'28'; ctx.strokeStyle=c0; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(14,10,82,55,7); ctx.fill(); ctx.stroke();
  ctx.fillStyle=c0; ctx.font='bold 42px monospace'; ctx.textAlign='center';
  ctx.shadowColor=c0; ctx.shadowBlur=14; ctx.fillText(scores[0],55,52);
  ctx.restore();

  ctx.save();
  ctx.fillStyle=c1+'28'; ctx.strokeStyle=c1; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(GW-96,10,82,55,7); ctx.fill(); ctx.stroke();
  ctx.fillStyle=c1; ctx.font='bold 42px monospace'; ctx.textAlign='center';
  ctx.shadowColor=c1; ctx.shadowBlur=14; ctx.fillText(scores[1],GW-55,52);
  ctx.restore();

  // Pips
  for (let i=0; i<WIN; i++) {
    ctx.save(); ctx.fillStyle=i<scores[0]?c0:c0+'25'; ctx.shadowColor=c0; ctx.shadowBlur=i<scores[0]?9:0;
    ctx.beginPath(); ctx.arc(106+i*14,30,4.5,0,Math.PI*2); ctx.fill(); ctx.restore();
    ctx.save(); ctx.fillStyle=i<scores[1]?c1:c1+'25'; ctx.shadowColor=c1; ctx.shadowBlur=i<scores[1]?9:0;
    ctx.beginPath(); ctx.arc(GW-106-i*14,30,4.5,0,Math.PI*2); ctx.fill(); ctx.restore();
  }

  // Env name
  ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle='#aabbdd';
  ctx.font='11px monospace'; ctx.textAlign='center'; ctx.fillText(ENVS[envIdx].name,GW/2,15); ctx.restore();

  // Wildcard chip
  if (curWC) {
    const cw=192,ch=23,cx=GW/2-cw/2,cy=22;
    ctx.save(); ctx.globalAlpha=0.82;
    ctx.fillStyle='#000000bb'; ctx.beginPath(); ctx.roundRect(cx,cy,cw,ch,5); ctx.fill();
    ctx.strokeStyle=curWC.col; ctx.lineWidth=1.2; ctx.shadowColor=curWC.col; ctx.shadowBlur=8;
    ctx.beginPath(); ctx.roundRect(cx,cy,cw,ch,5); ctx.stroke();
    ctx.fillStyle=curWC.col; ctx.font='bold 11px monospace'; ctx.textAlign='center'; ctx.shadowBlur=0;
    ctx.fillText(curWC.icon+' '+curWC.name, GW/2, cy+15); ctx.restore();
  }

  // "Press [S/â†“] to shoot" label
  if (ball.holder) {
    const p=ball.holder;
    const key=p.team===0?'S':'â†“';
    ctx.save(); ctx.fillStyle=p.col; ctx.font='bold 11px monospace'; ctx.textAlign='center';
    ctx.shadowColor=p.col; ctx.shadowBlur=10; ctx.globalAlpha=0.92;
    ctx.fillText('['+key+'] TO SHOOT', p.x, p.y - 74*p.scale); ctx.restore();
  }

  // Controls
  ctx.save(); ctx.globalAlpha=0.36; ctx.font='11px monospace';
  ctx.fillStyle=c0; ctx.textAlign='left';
  ctx.fillText('CYAN:  A/D move   W jump   S grab/shoot', 16, GH-10);
  ctx.fillStyle=c1; ctx.textAlign='right';
  ctx.fillText('ORANGE:  â†/â†’ move   â†‘ jump   â†“ grab/shoot', GW-16, GH-10);
  ctx.restore();

  // Announce banner
  if (annT>0 && ann) {
    annT--;
    const fade=Math.min(1, annT/28, (220-annT+1)/28);
    const bw=394,bh=78,bx=GW/2-bw/2,by=GH/2-158;
    ctx.save(); ctx.globalAlpha=fade;
    ctx.fillStyle='rgba(0,0,0,0.88)'; ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,10); ctx.fill();
    ctx.strokeStyle=ann.col; ctx.lineWidth=2.5; ctx.shadowColor=ann.col; ctx.shadowBlur=22;
    ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,10); ctx.stroke();
    ctx.font='bold 28px monospace'; ctx.textAlign='center';
    ctx.fillStyle=ann.col; ctx.shadowBlur=10; ctx.fillText(ann.text, GW/2, by+32);
    ctx.font='13px monospace'; ctx.fillStyle='#cccccc'; ctx.shadowBlur=0;
    ctx.fillText(ann.sub, GW/2, by+56); ctx.restore();
  }
}

function drawMenu() {
  drawBg();
  const now=Date.now()*0.001;
  for (let i=0; i<2; i++) {
    const ox=i===0?GW/2-212:GW/2+212;
    const oy=FLOOR_Y-38+Math.sin(now+i*1.5)*10;
    const col=i===0?'#00ccff':'#ff6600';
    const dark=i===0?'#003d55':'#552200';
    const vis=i===0?'#002244':'#441100';
    const f=i===0?1:-1;
    ctx.save(); ctx.translate(ox,oy); ctx.scale(1.3,1.3);
    ctx.lineCap='round'; ctx.lineWidth=7; ctx.shadowColor=col; ctx.shadowBlur=12;
    ctx.fillStyle=col; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=dark; ctx.beginPath(); ctx.arc(f,-1,7.5,Math.PI*1.05,Math.PI*2); ctx.fill();
    ctx.fillStyle=vis; ctx.beginPath(); ctx.arc(f*2,-2,4,Math.PI*1.1,Math.PI*1.9); ctx.fill();
    ctx.strokeStyle=col;
    ctx.beginPath(); ctx.moveTo(0,12); ctx.lineTo(0,48); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,27); ctx.lineTo(f*22,39); ctx.moveTo(0,27); ctx.lineTo(-f*18,39); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,48); ctx.lineTo(-12,72); ctx.moveTo(0,48); ctx.lineTo(12,72); ctx.stroke();
    ctx.restore();
  }
  ctx.textAlign='center';
  ctx.save(); ctx.globalAlpha=0.10; ctx.font='bold 92px monospace'; ctx.fillStyle='#fff';
  ctx.fillText('STICK BASKET',GW/2+3,GH/2-48); ctx.restore();
  ctx.save(); ctx.font='bold 88px monospace';
  ctx.fillStyle='#00ccff'; ctx.shadowColor='#00ccff'; ctx.shadowBlur=26+8*Math.sin(now*1.4);
  ctx.fillText('STICK',GW/2-102,GH/2-46); ctx.restore();
  ctx.save(); ctx.font='bold 88px monospace';
  ctx.fillStyle='#ff6600'; ctx.shadowColor='#ff6600'; ctx.shadowBlur=26+8*Math.sin(now*1.4+1);
  ctx.fillText('BASKET',GW/2+104,GH/2-46); ctx.restore();
  ctx.save(); ctx.strokeStyle='#2233aa'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(GW/2-188,GH/2-14); ctx.lineTo(GW/2+188,GH/2-14); ctx.stroke(); ctx.restore();
  ctx.save(); ctx.font='13px monospace'; ctx.fillStyle='#6677aa'; ctx.globalAlpha=0.85;
  ctx.fillText('2 PLAYERS  Â·  SPACE CHAMPIONSHIP  Â·  FIRST TO '+WIN,GW/2,GH/2+14); ctx.restore();
  ctx.save(); ctx.font='12px monospace'; ctx.globalAlpha=0.8;
  ctx.fillStyle='#00ccff'; ctx.fillText('CYAN:   [A][D] Move   [W] Jump   [S] Grab & Shoot',GW/2,GH/2+47);
  ctx.fillStyle='#ff6600'; ctx.fillText('ORANGE:  [â†][â†’] Move   [â†‘] Jump   [â†“] Grab & Shoot',GW/2,GH/2+67);
  ctx.restore();
  const blink=Math.sin(now*3.5)>0;
  ctx.save(); ctx.globalAlpha=blink?1:0.4;
  ctx.font='bold 16px monospace'; ctx.fillStyle='#ffffff'; ctx.shadowColor='#ffffff'; ctx.shadowBlur=8;
  ctx.fillText('PRESS  ENTER  TO  LAUNCH',GW/2,GH/2+108); ctx.restore();
}

function drawGameOver() {
  drawBg(); drawPlatforms();
  for (const h of HOOPS) drawHoopBack(h);
  drawBall();
  for (const h of HOOPS) drawHoopFront(h);
  drawParts();
  const win=scores[0]>=WIN?0:1;
  const wc=win===0?'#00ccff':'#ff6600';
  const now=Date.now()*0.001;
  ctx.save(); ctx.textAlign='center';
  ctx.font='65px sans-serif'; ctx.shadowColor=wc; ctx.shadowBlur=28; ctx.fillText('ðŸ†',GW/2,GH/2-88);
  ctx.font='bold 52px monospace'; ctx.fillStyle=wc; ctx.shadowColor=wc; ctx.shadowBlur=20+10*Math.sin(now*2);
  ctx.fillText(win===0?'TEAM CYAN':'TEAM ORANGE',GW/2,GH/2-24);
  ctx.font='bold 22px monospace'; ctx.fillStyle='#ffffff'; ctx.shadowBlur=6;
  ctx.fillText('WINS THE CHAMPIONSHIP',GW/2,GH/2+20);
  ctx.font='18px monospace'; ctx.fillStyle='#9999cc'; ctx.shadowBlur=0;
  ctx.fillText(scores[0]+'  â€”  '+scores[1],GW/2,GH/2+52);
  ctx.globalAlpha=Math.sin(now*3)>0?1:0.4; ctx.font='14px monospace'; ctx.fillStyle='#aaaacc';
  ctx.fillText('PRESS ENTER TO RETURN',GW/2,GH/2+104);
  ctx.restore();
}

// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime=0;
function loop(ts) {
  requestAnimationFrame(loop);
  const rawDt = Math.min((ts-lastTime)/16.67, 2.5);
  lastTime=ts;
  const dt = rawDt * (state===S.PLAYING ? TIMESC : 1);
  ctx.clearRect(0,0,GW,GH);

  if (state===S.MENU) {
    drawMenu();
    if (pressed['Enter']||pressed['Space']) startGame();
    clearPressed(); return;
  }
  if (state===S.GAMEOVER) {
    drawGameOver(); tickParts();
    if (pressed['Enter']||pressed['Space']) state=S.MENU;
    clearPressed(); return;
  }

  drawBg(); drawPlatforms(); drawBlackHole();

  if (state===S.PLAYING) {
    updateBall(dt);
    for (const p of players) p.update(dt);
    playerCollisions();
    ballPlayerPhysics();
    tickParts();
    checkScore();
  } else if (state===S.ROUND_END) {
    tickParts();
    roundEndT-=rawDt;
    if (roundEndT<=0) { state=S.PLAYING; nextRound(); }
  }

  for (const h of HOOPS) drawHoopBack(h);
  drawBall();
  for (const h of HOOPS) drawHoopFront(h);
  for (const p of players) p.draw();
  drawParts();
  drawHUD();
  clearPressed();
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
plats = LAYOUTS[0].map(p=>({...p}));
spawnPlayers();
resetBall();
requestAnimationFrame(loop);
</script>
</body>
</html>
